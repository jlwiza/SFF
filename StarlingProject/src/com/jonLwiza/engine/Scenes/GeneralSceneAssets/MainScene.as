package com.jonLwiza.engine.Scenes.GeneralSceneAssets{			import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.GeneralElements.Director;	import com.jonLwiza.engine.GeneralElements.GroupDynamix;	import com.jonLwiza.engine.GeneralElements.Path;	import com.jonLwiza.engine.actors.BaddieBoss;	import com.jonLwiza.engine.actors.Camera;	import com.jonLwiza.engine.actors.Hero;	import com.jonLwiza.engine.actors.Hornet;	import com.jonLwiza.engine.actors.MainStage;	import com.jonLwiza.engine.actors.MetalMonkeys;	import com.jonLwiza.engine.actors.Scenary;	import com.jonLwiza.engine.baseConstructs.AnimationHandler;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.baseConstructs.GeneralAnimation;	import com.jonLwiza.engine.baseConstructs.GeneralMotor;	import com.jonLwiza.engine.baseConstructs.SceneHandler;	import com.jonLwiza.engine.helperTypes.Status;	import com.jonLwiza.engine.helperTypes.Vector3;		import flash.display.Scene;	import flash.events.Event;	import flash.geom.Point;	import flash.utils.Dictionary;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import away3d.primitives.SkyBox;	import away3d.textures.BitmapCubeTexture;	import away3d.utils.Cast;		import starling.display.DisplayObject;	import starling.display.MovieClip;	import starling.textures.Texture;
		// what would be better than this is make a generic scene for things that i want to happen whenever we enter a new scene	public class MainScene extends SceneHandler	{				// ok so the whole thing that i did on the behavior is that i was able to ater select parts of the		// behavior states by changing this thing from null to something else what it does if i just change the thing from null to an animation i can just alter the name		// its actually pretty clever, nice job jon it should just change the animation, but I can change the behavior by first changing it from null that marks the behavior can be changed if its first on the stack of scenes		// and then we can change its behavior right there by editing the state on that machine i think sonic is passed through here but im not sure if not dont matter		// anyway it gives a lot of power flexibility very cheaply its a nice system i came up with pretty quick and its very non invasive 		private var _msm:MainSceneMotor = new MainSceneMotor();				// to publicize this, what I shoould do is update the mainScene motor make suer that you have an input of mainScene motor and that has to implement gravity scene and whatnot, and camera i suppose toom this will probably confusing for people, might be better if they dont touch it, but their choice		protected var actrPath:String = "com.jonLwiza.engine.actors::"		private var _sonicRising:String = null;		private var _sonicwaiting:String  = null;		private var _sonicdying:String  = null;		private var _sonicDead:String = null;		private var _sonicFalling:String = null;		private var _sonicHanging:String = null;		private var _sonicJumpRising:String  = null;		private var _sonicJumpFalling:String  = null;		private var _sonicJogging:String = null;		private var _sonicRunning:String = null;		private var _sonicSprinting:String = null;		private var _sonicRolling:String  = null;		private var _sonicIdle:String = null;		private var _sonicPissed:String = null;		private var _sonicWalking:String = null;		private var hornetDead:String = "hornetDead";		private var monkeyDead:String = "monkeyDead";		//private var metalMonkey:MetalMonkeys = new MetalMonkeys();		private var _sonicCharging:String  = null;		private var _sonicDucking:String  = null;		private var _sonicSkid:String  = null;		private var _jumpCharging:String = null;		private var bBossThrowing:String = "throwSonic";		private var bBossDiving:String = "diveAtSonic";		private var bBossHolding:String = "holdingSonic";		public var camPath:Path = new Path		public var camRtPath:Path = new Path		private var _hornetIdle:String = "hornetIdle"		private var textureLoadCount:int = 0;		public static var director:Director		public static var hero:Hero		// this is the array of textures that is loaded when the scene is added, whatever that means		// ill use a txt file that can be updated 		public var textureList:Array = [];		public var groundPts: Array = [];		public var hornets:Array = [];		//public var hornetImage:String = "hornet"		public var rings:Array = [];		public var subScenes:Array = [];		public var scenary:Array = [];		private var scenaryloaded:Boolean;		public var linkedCamPos:Vector3 = new Vector3();		public var linkedCamRot:Vector3 = new Vector3();		private var once:Boolean;		public var CamRotPath:Boolean = true;		public var autoCamFollow:Boolean = true;		private var _skyboxTextures:Vector.<String>;		private var loadedTextures:int = 0;		private var startedLoading:Boolean = false;		public var pos:Point = new Point();		public var beg:Number;		public var end:Number;		public var p:Path = new Path()		public var animAngles:Array = []//[0,120,270]		public var resultingAng:Number = 0		private var isinitSorted:Boolean = false;		private var ticker:int = 0;		public var isConstantSort:Boolean = true;		private var _sortRefreshRate:int  = 5;		public var isFollowingHero:Boolean = true;		public var flashAnims:Dictionary = new Dictionary;		public var jumpDash:String = "jumpDash";		public var SonicCustomState:Object;		private var linkedCamVal:Number;		public function MainScene()		{			super();						//name = "MainScene"			//set up arrays in here or something i dunno		}				//Main scene shhould of also taken in the key presses... oh well		public function relativePosition(ptsArray:Array):Array{			for (var j:int =ptsArray.length-1; j > 0; j--) 			{				if(j == 1){										ptsArray[1].Y = ptsArray[1].Y - ptsArray[0].Y					ptsArray[1].X = ptsArray[1].X - ptsArray[0].X  					ptsArray[1].Z = ptsArray[1].Z - ptsArray[0].Z					ptsArray[0].X = 0					ptsArray[0].Y =0					ptsArray[0].Z = 0					//trace("X = ",p.ptsArray[1].X," ",p.ptsArray[0].X)				}else{					ptsArray[j].X = ptsArray[j].X - ptsArray[j-1].X  					ptsArray[j].Y = ptsArray[j].Y - ptsArray[j-1].Y					ptsArray[j].Z = ptsArray[j].Z - ptsArray[j-1].Z				}				//trace("X = ",ptsArray[j].X," ",ptsArray[j-1].X)			}			return ptsArray		}		//pointless function but it tells us were preparing for animation		public function initWithName(name:String):void		{						this.name = name;			// this supposes animation		}		// this is rough cuz im dumb but this is  saying		// the function onqueload basically preps everything and starts loading all the new stuff into stage mc		// on these were gonna load everythin but in the game it would make sense just to load whats up in the first scene, ya heard?		//these are only for the cuts, so they should be there but um, its not a bad idea to load textures		/**		 * the function is designed to be optimized so that you can by default		 * front load all the textures or put in a specific set of textures		 */		public function OnQueLoad(textures:Array = null):void{						if(name== null)			throw Error("this scene requires a name")									if (textureLoadCount < textureList.length - 1) 
			{
				Assets.LoadTexture(textureList[textureLoadCount],1000,this.name,this)
			}else{				//itll work but i dont think this error makes sense				throw Error("the scene "+this.name+" is done loading assets")			}					}				public function AddTo(actor:Hero):void{			HeroEntered();		}		// so when i optimize you put the the extra animations into a scenary thing in the scene		public function sceneSwap():void		{			if(textureList.length-1 == textureLoadCount)			{				ResourceManager[this.name]()				stage_mc.setMap()			}		}				public function textureLoaded():void		{			// query load next			if(textureList.length-1 == textureLoadCount){//				//trace("textures for "+this.name+"have finished loading")				// texture if i remove these textures from memory i should reset texture load count			}else{				textureLoadCount++;				Assets.LoadTexture(textureList[textureLoadCount],1000,this.name,this)			}					}		protected function SetSkyBox():void		{			var cubeTexture:BitmapCubeTexture = new BitmapCubeTexture(Cast.bitmapData(Assets.bitmap[skyboxTextures[0]]),				Cast.bitmapData(Assets.bitmap[skyboxTextures[1]]),				Cast.bitmapData(Assets.bitmap[skyboxTextures[2]]),				Cast.bitmapData(Assets.bitmap[skyboxTextures[3]]),				Cast.bitmapData(Assets.bitmap[skyboxTextures[4]]),				Cast.bitmapData(Assets.bitmap[skyboxTextures[5]]))			ResourceManager.skyBox = new SkyBox(cubeTexture)			if(!Main.Release){			LevelEditor.away3dView.scene.addChild(ResourceManager.skyBox)			}else{				StarlingProject.away3dView.scene.addChild(ResourceManager.skyBox)							}		}		public function loadSkyBox():void{			if(skyboxTextures.length != 0){				if(loadedTextures < skyboxTextures.length){					if(!Assets.isTextureLoaded(skyboxTextures[loadedTextures]))					{						if(!startedLoading){							Assets.LoadTexture(skyboxTextures[loadedTextures])							startedLoading = true						}											}else{						loadedTextures++							startedLoading = false					}				}else{					if(!startedLoading){						SetSkyBox()						startedLoading = true					}				}			}					}		public function allLoaded():Boolean		{			if(scenaryloaded == true && Assets.isLoadQueOn){				return true			}						for (var i:uint = 0; i < Director.scenary.length; i++) 			{								if(!Main.liveCamera.scenary[i])				{										return false				}			}												scenaryloaded = true			var n:uint  = Director.scenary.length			var cm:MainStage = Main.liveCamera//			Main.liveCamera.setChildIndex(Main.liveCamera. hero_mc,0)//			Main.liveCamera.sortChildren(sortScenary)			// when i save it should import on this order so that i actually dont need this			// since scenary should stay stationary						return true		}		// I should have more efficient sorting and Ill make a note to do that		public function sortScenary(object1:DisplayObject, object2:DisplayObject):int		{if(!(object1 is GeneralMotor && object2 is GeneralMotor))			return 0			var y1:Number = GeneralMotor(object1).zp;			var y2:Number = GeneralMotor(object2).zp;						//trace(this, "sortStuff y1:", y1, "y2", y2);						if (y1 > y2)				return -1;						if (y1 < y2)				return 1;						return 0;					}		//override protected function allLoaded(event:Event):void//		{//			//		}				// all this stuff even though it seems round about give more flexibility to the scene, because for a specific scene all i have to do is overide a specific function and thatll get me the		// functionality i want, its just so i can be lazy and dont have to subclass a new a new motor and what not, takes away a bit from MVC but eh.. you could argue why not move the actual		// functionality here but then i dunno how big motor could get so this is good for now, that and most scenes will just subclass this bad boy, and make little alterations, that makes		// it easier without overloading in code, because the extra scene functionality will never get that big, and if it does, I have the option to rewire instead of subclassing the 		// motor class in some weird way				public function init(hero:Hero):void
		{			
			msm.init(hero)
		}		// you cant generalize this it onlyworks for the hero since it only checks if the hero is in there		override public function Update(actor:Hero = null):void		{			UpdatePhysicsProcess()			HeroMotion(actor)								// i made this so I can just put some extra functionality without disturbing the mainScene set up aka I dont wanna have to keep rewriting this garbage, or whatever garbage I put here		// but if i want i can start from scratch and use a different thing to process motion if i override this one, but just dont override it, unless all of a sudden i go into outerspace			// or whatever						if(allLoaded()){			if(LevelEditor.liveEdit){							// honestly it should be the same but i just wanna check something something first				scneEditor.UpdateScene(actor, this);				}else{				if(!isinitSorted){					ticker++					if(ticker > 30){						//Main.liveCamera.setChildIndex(Main.liveCamera. hero_mc,0)						Main.liveCamera.sortChildren(sortScenary)					if(!isConstantSort){					isinitSorted = true					}					ticker = 30 - sortRefreshRate					}				}				//it should be something like alteredList[i].inAlter = false				//Main.liveCamera.hero_mc.inAlter = false				UpdateScene(actor);											}			}else{								if(LevelEditor.liveEdit){										// honestly it should be the same but i just wanna check something something first					scneEditor.preloadedUpdateScene(actor, this);					}else{					// its extra functionality if you wanna do things while its preloading, 					preloadedUpdateScene(actor);				}							}						}				protected function preloadedUpdateScene(actor:Hero):void
		{
			// TODO Auto Generated method stub
			
		}				private function UpdatePhysicsProcess():void
		{
			msm.UpdatePhysicsProcess()
		}				protected function HeroMotion(actor:Hero = null):void		{			msm.ProcessMotion(actor);		}		/**		 * in the Main scene all i did was make a linkedCam Pos where i can do what i like with it		 */		protected function UpdateScene(actor:GeneralActor = null):void		{					}		public function defaultHeroEntered(actor:GeneralActor):void		{//			//trace(" so that ok ")		}		public function defaultUpdateScene(actor:GeneralActor):void		{//			//trace(this.stage_mc)//			for (var i:int = 0; i < stage_mc.scnes.length; i++) //			{//				//			}			//stage_mc.hero_mc.Y--			//actor.alpha -=.05//				//trace("other thingies") 			//throw Error("some craps")		}				public function UpdateCamera(cam:MainStage = null, ctScene:String = null):void		{			msm.ProcessCameraMotion(cam);					//	ctScene.x = cam.pos.X - ctScene.width/1.9;			//	ctScene.y = cam.pos.Y - ctScene.height/1.4;			playCutScene(ctScene);			if(allLoaded()){								//YOOO WHAT THE FUCK IM SO CONFUSED BUT THIS Weird little hack fixed i so 				// I honestly dont know why this works at all cuz it should				//hmm if i had to guess is that this runs before the point gets placed				if(Director.Campath.length > 0 ){					if(camPath.ptsArray != Director.Campath ){						camPath.ptsArray = Director.Campath						camPath.lpair = Director.camlinkpair					}					linkedCamVal = camPath.linkedValue(hero.body.position.x)					linkedCamPos = camPath.placement(linkedCamVal);									}else{										// this is a complete unapologetic hack					if(isFollowingHero){					linkedCamPos.Z = Main.liveCamera.hero_mc.Z - 900;					linkedCamPos.X = Main.liveCamera.hero_mc.X;					linkedCamPos.Y = Main.liveCamera.hero_mc.Y;					}									}				if(Director.camRotation.length > 0){					if(camRtPath.ptsArray != Director.camRotation){						camRtPath.ptsArray = Director.camRotation																	camRtPath.lpair = Director.camRotLink						camRtPath.isDistanceChecked = false					}										linkedCamVal = camRtPath.linkedValue(hero.body.position.x)								linkedCamRot = camRtPath.placement(linkedCamVal);									}				if(!Main.Release){				if(LevelEditor.isFollowPath && autoCamFollow){					LevelEditor.awyCam.z = linkedCamPos.Z					LevelEditor.awyCam.y = linkedCamPos.Y					LevelEditor.awyCam.x = linkedCamPos.X										}				// I wonder why I didnt just use is follow path again hmm.. oh well 				if(LevelEditor.isFollowPath && CamRotPath ){					LevelEditor.awyCam.rotationZ = linkedCamRot.Z					LevelEditor.awyCam.rotationY = linkedCamRot.Y					LevelEditor.awyCam.rotationX = linkedCamRot.X				}				}else{					if(StarlingProject.isFollowPath && autoCamFollow){						StarlingProject.awyCam.z = linkedCamPos.Z						StarlingProject.awyCam.y = linkedCamPos.Y						StarlingProject.awyCam.x = linkedCamPos.X											}					// I wonder why I didnt just use is follow path again hmm.. oh well 					if(StarlingProject.isFollowPath && CamRotPath ){						StarlingProject.awyCam.rotationZ = linkedCamRot.Z						StarlingProject.awyCam.rotationY = linkedCamRot.Y						StarlingProject.awyCam.rotationX = linkedCamRot.X					}				}											}		}				public function addAnimationToActor(actor:GeneralActor,anim:String):void{			var res:Vector.<starling.textures.Texture> = new <starling.textures.Texture>[]						for(var i:int=1;Assets.isTextureLoaded(anim,i);i++){				if(i < 10)					res.push(Assets.getTexture(anim+"000"+i))				else					res.push(Assets.getTexture(anim+"00"+i))			}						actor.playedAnimations[anim] = new MovieClip(res)					}				protected function playCutScene(ctScene:String):void
		{			
		}				// I made all these override public for the simple reason if I want some entity to turn the gravity or sonics jumps movement whatever on and off they can						public function ground(hero:Vector3, actor:GeneralActor):void		{			msm.ground(actor.bdy.x);		}				public function Jump(actor:GeneralActor):void		{			msm.Jump(actor);					}				public function additionalForces(cam:MainStage):void		{			msm.additionalForces(cam);		}		//snaps to path or doesnt snap to path update gravity is a dumb name for thi		public function UpdatePhysicsActor(hero:Vector3, actor:GeneralActor):void		{			msm.UpdatePhysicsActor(actor);					}								public function SonicDoubleJump(actor:GeneralActor):void		{//			//trace("sonic should be double JUMPING")			// this should go to sonic, which then sonic then handles it that way, we should call whatever actors super it is then find its implementation of this and it would go from there 			if(!Hero(actor).hanging)			msm.homingAttack(actor, 3,2000);		}						public function ProcessCameraMotion(cam:MainStage):void		{						msm.ProcessCameraMotion(cam);		}				//SONIC'S STATES OF BEHAVIOR				public function SonicCharging(actor:GeneralActor):String		{			if(sonicCharging != null)			return Hero(actor).SonicCharging(sonicCharging+resultingAngtoString());			else			return Hero(actor).SonicCharging("sonicCharging");		}						public function SonicJumpDash(actor:GeneralActor):String		{			if(jumpCharging != null)				return Hero(actor).JumpDash(jumpDash+resultingAngtoString());			else				return Hero(actor).JumpDash("jumpDash");		}				// it runs if hero.customstate = true you get full control and just change sonicCustom animation to change the animation to anything you want		public function SonicCustom(actor:GeneralActor):String		{							return Hero(actor).SonicCustomState(SonicCustomState);		}				public function JumpCharge(actor:GeneralActor):String		{			if(jumpCharging != null)			return Hero(actor).JumpCharge(jumpCharging+resultingAngtoString());			else			return Hero(actor).JumpCharge("jumpCharging");		}						public function SonicDucking(actor:GeneralActor):String		{			if(sonicDucking != null)			return Hero(actor).SonicDucking(sonicDucking+resultingAngtoString());			else			return Hero(actor).SonicDucking("sonicDucking");		}				public function SonicSkidding(actor:GeneralActor):String		{			if(sonicSkid != null)			return Hero(actor).SonicSkid(sonicSkid+resultingAngtoString());			else			return Hero(actor).SonicSkid("sonicSkid");		}						public function SonicWaiting(actor:GeneralActor):String		{			if(sonicwaiting != null)			return Hero(actor).SonicWaiting(sonicwaiting+resultingAngtoString());			else			return Hero(actor).SonicWaiting("sonicwaiting");		}				public function SonicDying(actor:GeneralActor):String		{			if(sonicdying != null)			return Hero(actor).SonicDying(sonicdying+resultingAngtoString());			else			return Hero(actor).SonicDying("sonicdying");		}				public function Dead(actor:GeneralActor):String		{						switch(getQualifiedClassName(actor))			{				case actrPath.concat("Hero"):				{					return SonicDead(actor)					break;				}				case actrPath.concat("MetalMonkeys"):				{					return MetalMonkeyDead(actor)					break;				}									default:				{					return Status.S_INVALId					break;									}			}					}				private function MetalMonkeyDead(actor:GeneralActor):String		{			// TODO Auto Generated method stub			return null//MetalMonkeys(actor).MetalMonkeyDead(monkeyDead);		}				public function BBossThrowing(actor:GeneralActor):String		{			return BaddieBoss(actor).BBossThrowing(bBossThrowing)		}		public function BBossHolding(actor:GeneralActor):String		{			return BaddieBoss(actor).BBossHolding(bBossHolding)		}		public function BBossDiving(actor:GeneralActor):String		{			return BaddieBoss(actor).BBossDiving(bBossDiving)		}				public function SonicDead(hero:GeneralActor):String		{			//if actor.lastAnimationState air different one for air and ground, ill handle specific animation to the state from the flash interface																	// this was a tough call onwhat to do with this i first thought to do the qualified string then i thought to use inheretance that way i could just override the function but realized that would limit each change to each scene 				// with a switch thatement 							//			// there has to be a clearner way to do this			if(sonicDead != null)			return Hero(hero).SonicDead(sonicDead+resultingAngtoString());			else			return Hero(hero).SonicDead("sonicDead");		}				/** tnis checks the array animangles and sees if there are any angles if there are it finds the nearest angle to our actul facing angle		 **/		protected function resultingAngtoString(actor:GeneralAnimation = null):String
		{			if(actor == null)				actor = hero
			resultingAng = animAngles[0]				if(animAngles.length == 0){					return ""				}			for (var i:int = 1; i <animAngles.length; i++) 			{				if(Math.abs(resultingAng - actor.facingAngle)  > Math.abs(animAngles[i] - actor.facingAngle)){										resultingAng = animAngles[i]									}			}			var myAngleName:String = resultingAng.toString()+"_"
			return myAngleName;
		}						// this is part of the behavior tree		 public function groupFight(actor:GeneralActor):String		 {						 return GroupDynamix(actor).Fight()		 }						public function SonicRising(actor:GeneralActor):String		{			// rising and falling andjump rising and jump falling need to be rewritten , they need to go to General actor which will have the shared stuff			// then that thing will ping back here to another method thats basically this but since itll know what it is it will be neater			if(sonicRising != null)			return Hero(actor).SonicRising(sonicRising);			else			return Hero(actor).SonicRising("sonicRising"+resultingAngtoString());		}				public function SonicGround(actor:GeneralActor):String		{			// rising and falling andjump rising and jump falling need to be rewritten , they need to go to General actor which will have the shared stuff			// then that thing will ping back here to another method thats basically this but since itll know what it is it will be neater			return Hero(actor).SonicGround();		}				public function SonicFalling(actor:GeneralActor):String		{			if(sonicFalling != null)			return Hero(actor).SonicFalling(sonicFalling);			else			return Hero(actor).SonicFalling("sonicFalling"+resultingAngtoString());		}		// just override these to get more granualler control		public function SonicJumpRising(actor:GeneralActor):String		{			if(sonicJumpRising != null)			return Hero(actor).SonicJumpRising(sonicJumpRising);			else			return Hero(actor).SonicJumpRising("sonicJumpRising"+resultingAngtoString());		}				public function SonicJumpFalling(actor:GeneralActor):String		{			if(sonicJumpFalling != null)			return Hero(actor).SonicJumpFalling(sonicJumpFalling);			else			return Hero(actor).SonicJumpFalling("sonicJumpFalling"+resultingAngtoString());		}				public function SonicHanging(actor:GeneralActor):String		{			if(sonicHanging != null)			return Hero(actor).SonicHanging(sonicHanging);			else			return Hero(actor).SonicHanging("sonicHanging"+resultingAngtoString());		}						public function SonicWalking(actor:GeneralActor):String		{			if(sonicWalking != null)			return Hero(actor).SonicWalking(sonicWalking);			else			return Hero(actor).SonicWalking("sonicWalking"+resultingAngtoString());					}				public function SonicJogging(actor:GeneralActor):String		{			if(sonicJogging != null)			return Hero(actor).SonicJogging(sonicJogging);			else			return Hero(actor).SonicJogging("sonicJogging"+resultingAngtoString());		}				public function SonicRunning(actor:GeneralActor):String		{			if(sonicRunning != null)			return Hero(actor).SonicRunning(sonicRunning);			else			return Hero(actor).SonicRunning("sonicRunning"+resultingAngtoString());		}				public function SonicSprinting(actor:GeneralActor):String		{			if(sonicSprinting != null)			return Hero(actor).SonicSprinting(sonicSprinting);			else			return Hero(actor).SonicSprinting("sonicSprinting"+resultingAngtoString());		}		public function SonicRolling(actor:GeneralActor):String		{			if(sonicRolling != null)			return Hero(actor).SonicRolling(sonicRolling);			else			return Hero(actor).SonicRolling("sonicRolling"+resultingAngtoString());		}				public function SonicIdle(actor:GeneralActor):String		{			if(sonicIdle != null)			return Hero(actor).SonicIdle(sonicIdle);			else			return Hero(actor).SonicIdle("sonicIdle"+resultingAngtoString());		}				public function SonicPissed(actor:GeneralActor):String		{			throw Error			if(sonicPissed != null)			return Hero(actor).SonicPissed(sonicPissed);			else			return Hero(actor).SonicPissed("sonicPissed"+resultingAngtoString());		}						// this can be changed to general actor later, but id have to move stuff, because tails might be just waiting around himself, but i dunno if there is gonna be another so yeah		// actually im making this generic at some point so yeah		        public function BaddieBehavior(actor:GeneralActor):String		{			return Baddie(actor).BaddieBehavior();					}				public function Waiting(actor:GeneralActor):String		{			return Baddie(actor).Waiting();		}		public function DeadBaddie(actor:GeneralActor):String		{			return Baddie(actor).Dead();		}				public function Throwing(actor:GeneralActor):String		{						return Baddie(actor).Thrown();		}		public function reactToTaunt(baddie:Baddie):void		{			baddie.attackingState = true;			baddie.justAttacked = false;		}				public function Attacking(actor:GeneralActor):String		{			return Baddie(actor).Attacking();				}				public function HeldOn(actor:GeneralActor):String		{						return Baddie(actor).Held();				}								// animations and generic stuff				public function Running(hero:Hero):void		{			// overide the running yay		}				public function Walking(hero:Hero):void		{			// override the walking yay		}		public function get sonicRising():String		{			return _sonicRising;		}		public function set sonicRising(value:String):void		{			_sonicRising = value;		}		public function get sonicwaiting():String
		{
			return _sonicwaiting;
		}		public function set sonicwaiting(value:String):void
		{
			_sonicwaiting = value;
		}		public function get sonicdying():String
		{
			return _sonicdying;
		}		public function set sonicdying(value:String):void
		{
			_sonicdying = value;
		}		public function get sonicDead():String
		{
			return _sonicDead;
		}		public function set sonicDead(value:String):void
		{
			_sonicDead = value;
		}		public function get sonicFalling():String
		{
			return _sonicFalling;
		}		public function set sonicFalling(value:String):void
		{
			_sonicFalling = value;
		}		public function get sonicJumpRising():String
		{
			return _sonicJumpRising;
		}		public function set sonicJumpRising(value:String):void
		{
			_sonicJumpRising = value;
		}		public function get sonicJumpFalling():String
		{
			return _sonicJumpFalling;
		}		public function set sonicJumpFalling(value:String):void
		{
			_sonicJumpFalling = value;
		}		public function get sonicHanging():String
		{
			return _sonicHanging;
		}		public function set sonicHanging(value:String):void
		{
			_sonicHanging = value;
		}		public function get sonicJogging():String
		{
			return _sonicJogging;
		}		public function set sonicJogging(value:String):void
		{
			_sonicJogging = value;
		}		public function get sonicRunning():String
		{
			return _sonicRunning;
		}		public function set sonicRunning(value:String):void
		{
			_sonicRunning = value;
		}		public function get sonicSprinting():String
		{
			return _sonicSprinting;
		}		public function set sonicSprinting(value:String):void
		{
			_sonicSprinting = value;
		}		public function get sonicRolling():String
		{
			return _sonicRolling;
		}		public function set sonicRolling(value:String):void
		{
			_sonicRolling = value;
		}		public function get sonicIdle():String
		{
			return _sonicIdle;
		}		public function set sonicIdle(value:String):void
		{
			_sonicIdle = value;
		}		public function get sonicPissed():String
		{
			return _sonicPissed;
		}		public function set sonicPissed(value:String):void
		{
			_sonicPissed = value;
		}		public function get sonicWalking():String
		{
			return _sonicWalking;
		}		public function set sonicWalking(value:String):void
		{
			_sonicWalking = value;
		}		public function get sonicCharging():String
		{
			return _sonicCharging;
		}		public function set sonicCharging(value:String):void
		{
			_sonicCharging = value;
		}		public function get sonicDucking():String
		{
			return _sonicDucking;
		}		public function set sonicDucking(value:String):void
		{
			_sonicDucking = value;
		}		public function get sonicSkid():String
		{
			return _sonicSkid;
		}		public function set sonicSkid(value:String):void
		{
			_sonicSkid = value;
		}		public function get jumpCharging():String
		{
			return _jumpCharging;
		}		public function set jumpCharging(value:String):void
		{
			_jumpCharging = value;
		}		public function get msm():MainSceneMotor
		{
			return _msm;
		}		public function set msm(value:MainSceneMotor):void
		{
			_msm = value;
		}		public function get hornetIdle():String
		{
			return _hornetIdle;
		}		public function set hornetIdle(value:String):void
		{
			_hornetIdle = value;
		}		public function get skyboxTextures():Vector.<String>
		{
			return _skyboxTextures;
		}		public function set skyboxTextures(value:Vector.<String>):void
		{
			_skyboxTextures = value;
		}		public function get sortRefreshRate():int
		{
			return _sortRefreshRate;
		}		public function set sortRefreshRate(value:int):void
		{
			_sortRefreshRate = value;
		}															}}