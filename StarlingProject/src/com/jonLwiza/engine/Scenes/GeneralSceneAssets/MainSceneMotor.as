package com.jonLwiza.engine.Scenes.GeneralSceneAssets{	import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.GeneralElements.Director;	import com.jonLwiza.engine.GeneralElements.Ground;	import com.jonLwiza.engine.IO.KeyPress;	import com.jonLwiza.engine.actors.Hero;	import com.jonLwiza.engine.actors.MainStage;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.baseConstructs.GeneralMotor;	import com.jonLwiza.engine.baseConstructs.NSprite;	import com.jonLwiza.engine.helperTypes.Vector3;		import flash.display.Sprite;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.media.Microphone;	import flash.utils.getTimer;		import away3d.cameras.lenses.PerspectiveLens;	import away3d.core.math.Vector3DUtils;		import nape.callbacks.CbEvent;	import nape.callbacks.CbType;	import nape.callbacks.InteractionCallback;	import nape.callbacks.InteractionListener;	import nape.callbacks.InteractionType;	import nape.constraint.PivotJoint;	import nape.geom.Vec2;	import nape.phys.Body;	import nape.phys.BodyType;	import nape.phys.Material;	import nape.shape.Circle;	import nape.shape.Polygon;	import nape.space.Space;	import nape.util.BitmapDebug;		import starling.core.Starling;	import starling.display.Sprite;
	public class MainSceneMotor	{		public static var accel:Number = 0.09;				// worldSpeed is  the number that controls how fast things are going		// implemented correctly i can use it to slow down elements		public static var worldSpeed:Number = 1 				public static var floor:Ground = new Ground();		private var moveSpeed:Vector3 = new Vector3(7,5);		private var moveVector:Vector3 = new Vector3(0,0);		private var actorPos:Vector3 = new Vector3();		private var _gravity:Number = 3;		private var _js:Number = -25;		private var gravAcceleration:Number;		private var _currState:String;		private var sfriction:Number = .5;		private var kfriction:Number = .95;		private var speedlimit:Number = 85;		private var camera:Vector3 = new Vector3();		private var scale:Number;		private var slope:Vector3 = new Vector3();		private var gv:Vector3 = new Vector3();		private var _motorHero:Hero = new Hero();		//vpx refers to the screen vanishing point when using orientation we change the movement relative		public static var vpX:Number = 424;		public static var vpY:Number = 240;		public static var fl:Number = 180;		private var x:Number = 0;		private var y:Number = 0;		private var cameraMoving:Boolean = true;		public static var space:Space;		public static var floorBody:Body;		public static var myDebugger:BitmapDebug		public static var editorStage:flash.display.Sprite;		public static var handJoint:PivotJoint;		public static var mouseJoint:PivotJoint;		public static var lastX:Number;		//private var m:MotorJoint;		private var pressedJump:Boolean = false;		private var debug:Boolean = true;		public static var ballCBType:CbType;		public static var floorCBType:CbType;		private var armaplaying:Boolean;		private var sprintSpeed:Number;				// these are put here so I can change em they have little to nothing to do with sonic more to do with camera and terrain		private var UpperZLimit:Number = 250;		private var lowerZLimit:Number = -200;		private var uinit:Boolean = false;		private static var cameraZ:Number = 0;;		private var _previousTime:Number = 0;		// this should be temporary but this shits complicated		//umm in here i could put in the propper jazz		//private var cameraPath:Path = new Path();		private var testing:Boolean;		public static var targetBaddie:CbType;		public static var thrownBaddie:CbType;		public static var hrnetBaddie:CbType;		public static var autoVP:Boolean = true;		public static var interupt:Boolean;		private var intrpt:Number;		public static var FreezeMotor:Boolean = false		private static var cameraMtrx:Array;		private var isGravityOn:Boolean = true;		public function MainSceneMotor()		{											}				public function init(hero:Hero):void		{			sprintSpeed = hero.sprintSpeed			ballCBType = new CbType();			floorCBType = new CbType();			hrnetBaddie = new CbType()			space = new Space(Vec2.weak(0,-1000));			space.listeners.add(				new InteractionListener( CbEvent.BEGIN, InteractionType.COLLISION, floorCBType, ballCBType, OnCollision));			space.listeners.add(				new InteractionListener( CbEvent.END, InteractionType.COLLISION, floorCBType, ballCBType, deCollision));			// we can optimize this cuz hornet thing might get hectic but uh we'll leave for now			space.listeners.add(				new InteractionListener( CbEvent.BEGIN, InteractionType.SENSOR, hrnetBaddie, ballCBType, HrntOnCollision));			space.listeners.add(				new InteractionListener( CbEvent.END, InteractionType.SENSOR, hrnetBaddie, ballCBType, HrntdeCollision));						thrownBaddie = new CbType();			targetBaddie = new CbType();			space.listeners.add(new InteractionListener( CbEvent.BEGIN, InteractionType.SENSOR, targetBaddie, thrownBaddie, BaddieHit))			_previousTime  = getTimer()						floorBody = new Body(BodyType.KINEMATIC)							//floorBody.shapes.add(new Polygon(Polygon.rect(300,4000,2000,1000,true)));			floorBody.shapes.add(new Polygon([Vec2.get(1000,4700),Vec2.get(6000,4700),Vec2.get(6000,5000),Vec2.get(1000,5000)]));			floorBody.cbTypes.add(MainSceneMotor.floorCBType);						floorBody.space = space			var heroBody:Body = new Body(BodyType.DYNAMIC);			heroBody.shapes.add(new Circle(30,null, new Material(0.1,5,.75,0.5)))			heroBody.position.setxy(50,50);			heroBody.space = space						//			var heroBody2:Body = new Body(BodyType.DYNAMIC);//			heroBody2.shapes.add(new Circle(30,null, new Material(0.1,1,5,.75,0.5)))//			heroBody2.position.setxy(50,50);//			heroBody2.space = space;			heroBody.userData.graphic = hero;			hero.body = heroBody;			hero.body.cbTypes.add(MainSceneMotor.ballCBType)//			var joint:DistanceJoint = new DistanceJoint(heroBody,heroBody2, new Vec2(0,0), new Vec2(0,0),60,70);//			joint.space = space//			joint.stiff = true;	//			var m:MotorJoint = new MotorJoint(heroBody,heroBody2);//			m.space = space;			handJoint = new PivotJoint(space.world, space.world, new Vec2, new Vec2);			handJoint.space = space;			handJoint.active = false;			mouseJoint = new PivotJoint(space.world, space.world, new Vec2, new Vec2);			mouseJoint.space = space;			mouseJoint.active = false;			// We also define this joint to be 'elastic' by setting			// its 'stiff' property to false.			//   We could further configure elastic behaviour of this			//   constraint through the 'frequency' and 'damping'			//   properties.			handJoint.stiff = false;			mouseJoint.stiff = false;			myDebugger = new BitmapDebug(848,480, 0x000000,true)			myDebugger.drawConstraints = true;			editorStage = new flash.display.Sprite();			Starling.current.nativeOverlay.addChild(editorStage);						Starling.current.nativeOverlay.addChild(myDebugger.display);					}				private function BaddieHit(e:InteractionCallback):void
		{
			var badBod:Body = e.int2 as Body;			// it has no user data			badBod.userData.graphic.strike = true;			//throw Error("WHATEVE")
			
		}			private function HrntdeCollision(e:InteractionCallback):void		{			var hrnt:Body = e.int1 as Body;			//hero.userData.graphic.isGrounded = false;			hrnt.userData.graphic.sonicCollision = false		}				private function HrntOnCollision(e:InteractionCallback):void		{						var hero:Body = e.int2 as Body;			var hrnt:Body = e.int1 as Body;			if(Math.abs(hero.userData.graphic.localZ - hrnt.userData.graphic.localZ) < 90)				hrnt.userData.graphic.sonicCollision = true			else				hrnt.userData.graphic.sonicCollision = false			//hero.userData.graphic.isGrounded = true;							}		private function deCollision(e:InteractionCallback):void
		{			if(Director.currSceneName != "HornetNest"){
			var hero:Body = e.int2 as Body;			//hero.userData.graphic.isGrounded = false;
			}		}				private function OnCollision(e:InteractionCallback):void
		{			// oh boy 			if(Director.currSceneName != "HornetNest"){
			var hero:Body = e.int2 as Body;						//hero.userData.graphic.isGrounded = true;						KeyPress.spacebar = false;			}			//////trace("grounded gh ")						// um yeah this is when setting up the water//			var water_shape:Shape = new Polygon(Vec2.get(x,y),Vec2.get(x,y),Vec2.get(x,y))//			water_shape.fluidEnabled = true;//			water_shape.fluidProperties.density = 3;//			water_shape.fluidProperties.viscosity = 10			//then uh add this bad boy			
			
		}				/**t:current frame b:startvalue c:change in value, d:duration**/		public static function Easein(t, b, c, d):Number {						t /= d;						return c*t*t*t*t*t + b;		}				/**t:current frame b:startvalue c:change in value, d:duration**/		public static function EaseOutQuint(t, b, c, d):Number {			t /= d;			t--;			return c*(t*t*t*t*t + 1) + b;		}				public function UpdateMotor(hero:GeneralActor):void		{			// Im hesitant to delete this.. but i could if i wanted to			hero.currScene[0].Update(hero);						//////trace(actor.key.direction.X,actor.key.direction.Y);		}				private function updateGraphics(body:Body):void
		{			
			var graphic:GeneralActor = body.userData.graphic;//			graphic.X = body.position.x;//			graphic.Y = body.position.y;						if(graphic.autoRotate)			graphic.rotation = body.rotation;
		}				public function UpdatePhysicsProcess():void{			if(debug)				myDebugger.clear()								//t1race(space)					//TODO:::: umm i just took away spaced stepping i think i need to do more to completely clean this up but its fine for now					if(!MainSceneMotor.FreezeMotor)				//space.step(1/30);						if(debug){				myDebugger.draw(space);								myDebugger.flush()								}		}		// I generalized it to null if I decide to subclass this		public function ProcessMotion(actor:Hero = null):void		{			var currentTime:Number = getTimer();												var dt:Number = 16/1000*worldSpeed//(currentTime - _previousTime)/1000;			_previousTime = currentTime;			// hmm i never actually have to save the position i could just integrate it in and out 						var a:Vector3D = actor.accel			var v:Vector3D = actor.vel							// lets have bdy be its 2 dimensional representation on here... hmmm, ok we'll make it a vector 3D just makes things easier to work with if its a vector3D 			///  I really wish flash had operator overloading uuuggghh									if(actor.key.X != 0 ){								a.x = actor.key.X;				//actor.moveSpeed.X *=.95;			}else{								// we'll just store it and say last key.X so yeah				a.x = actor.key.X											}			if(a.x!=0)				a.x *= .7019//.01*actor.vel.x							//TODO(JON):still need friction and additional weight and variant to the movement of sonic like slow build up going forward all that junk										// this seems like a nice mid accel but sonic has a really slow start up to begin with			var sonicSpeed:Number = actor.moveSpeed.X = 5000			if(actor.key.X == 0){				sonicSpeed = actor.moveSpeed.X = 10			}			// we'll have to derive sonic speed in a more dynamic way but this i good enough for now				a.x *=sonicSpeed							a.x -= v.x			// umm figure out offset y, work from there						//trace(dt, "is peed")			actor.bdy.x = a.x*1/2*dt*dt +v.x*dt + actor.bdy.x			actor.vel.x = a.x*dt +v.x														//lets graveity 				gravity = -300			if(!actor.isGrounded && isGravityOn){				a.y =gravity					//trace("the fuck is going one")			}						if(actor.isGrounded){				a.y = 0				v.y = 0					//TODO(JON): very important We have to actually have to get rid of this					// so sonic sticks to the ground unless i specifically say so 					// he cant move out of the ground out of his own momentum					// just use that stuck to ground paramater, the only problem is it tracks, the xz not the x y z, so he'll move very quickly in steep inclines					// eventually you will have to move so sonic is completely stuck to the path until i say he can fly off it or whatever				if(actor.isJumping){					if(actor.spacebar){						actor.canJump = false					}				actor.isJumping = false				}								if(!actor.spacebar){					actor.canJump = true				}					//trace("we are now on the ground")			}						// i cant do this because i need the released to fire just once//			if(!actor.spacebar){//				actor.spaceReleased = true//			}						// im going to put jump here 			if(actor.isGrounded && actor.spacebar && actor.canJump){				// so here we'd be like 								//TODO(JON): just get some of the movement code going on a lil bit and then 				// we have to test the backdoor thingy if it can get my code into the game and get my output from the game 				// once thats solid i can then finally start, on making the first fight in all its strangeness				// ok just check if it works				// oh i think that the thing doesnt just copy the right frames and copies others look at the implementation								v.y = 500				actor.isJumping = true;				actor.spaceReleased =false			}						if(actor.isJumping){				if(!actor.spacebar && !actor.spaceReleased && v.y > 300){					v.y = 300					actor.spaceReleased = true				}							}						// ok all 							actor.bdy.y = 1/2*a.y*dt*dt +v.y*dt + actor.bdy.y			actor.vel.y = a.y*dt +v.y							actor.bdy.z = a.z*1/2*dt*dt +v.z*dt + actor.bdy.z			actor.vel.z = a.z*dt +v.z											actor.currScene[0].UpdatePhysicsActor(actor.moveVector, actor);			actor.currScene[0].ground(actor.moveVector, actor);		//actor.currScene[0].additionalForces(MainStage(actor.parent));								return			//space.liveBodies.foreach(updateGraphics)			actorPos.X = actor.x;			actorPos.Y = actor.y;			if(interupt)			{				intrpt = actor.key.X			}else{				intrpt = 1;			}		//////trace(actor.closestConcern.Z," tiyr bub",actor.Z);			//////trace(Starling.context.driverInfo);			if (actor.moveVector.X >= 0) 			{//												actor.forward = true;				// this is pre camera moves since when the camera zooms it scales in size				actor.dir = 1			}else{												actor.forward = false				// this is pre camera moves since when the camera zooms it scales in size				actor.dir = -1			}			//actor.body.shapes.at(0).material.staticFriction = 1			//Camera(actor.parent).pos.Z ++			//////trace(actor.key.X);			// I dont think this will work  because accelleration just keeps getting larger and larger no matter what						if(actor.body.angularVel >= sprintSpeed && actor.isGrounded && !Hero(actor).skid){			if(actor.key.Y >0){				// this will all change so yeah				// use nape.normal perpe				actor.Z +=10;				if(actor.localZ > UpperZLimit)					actor.localZ = UpperZLimit						actor.localZ			}else if(actor.key.Y<0){				actor.localZ -=10;				if(actor.localZ < lowerZLimit)					actor.localZ = lowerZLimit			}			}					// I do it like  actor instead of direct so I can interrupt incase I wanna mock keypresses but want to get them from			// a different source than the keyboard PPPOOOOWWWWEERRRRR!!!!!			if(actor.spacebar && actor.isGrounded && actor.canJump)			{				actor.triggerJumping = true;				actor.doublejumped = false;				actor.passed = false;				actor.tryAndGrab = false; 				actor.tryDodge = false; 								//////trace("Jumping fdsgfs  gfds aa f");				//stage_mc.hero_mc.playAnimation("test");								//stage_mc.hero_mc.currScene[0].Jump(stage_mc.hero_mc);			}						if(!actor.isGrounded && actor.triggerJumping){				actor.isJumping = true;				actor.releasedDuringJump = false;				actor.triggerJumping = false;				//////trace(stage_mc.hero_mc.triggerJumping," HOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOWHOW",stage_mc.hero_mc.triggerJumping)											}//			scale = fl/(fl +actor.Z);//			//			// i hate doing this here since its so important but this is the only place you use the literal x and y's//			actor.scaleX = scale;//			actor.scaleY = scale;//			actor.x = vpX + (actor.X - vpX)*scale;//			actor.y = vpY + (actor.Y - vpY)*scale;			 			//			else//				if(moveSpeed.X > 3)//					moveSpeed.X -= accel;						//(actor.moveSpeed.X*actor.key.X);			if(actor.key.X != 0){				if (actor.isGrounded) 
				{										actor.body.torque = .5					actor.body.angularVel -=(.4*actor.moveSpeed.X*actor.key.X*intrpt);
				}else{					actor.body.velocity.x += 15*actor.key.X*intrpt;					// i should put something here so that you cant go faster in the air						actor.body.angularVel *= .9;						actor.body.torque = 4				}						}else{				if (actor.isGrounded) 				{			 actor.body.angularVel *= .9;			 if(Math.abs(actor.body.angularVel) < .1)				 actor.body.angularVel = 0;						 //			 ////trace("angular velocity ",actor.body.angularVel)				}			}							//actor.localZ +=-6*actor.key.Y						//////trace(actor.body.angularVel)			//if(!actor.isGrounded)			if(actor.scaleX != actor.dir)			actor.scaleX *= actor.dir			//moveVector.X *=.9;			//////trace("move vector: ", moveVector.X)			//actorPos.X +=actor.moveVector.X;			//actor.moveVector.X = actor.body.velocity.x;			//actor.moveVector.Y = actor.body.velocity.y;								//probably need to subclass a method motorstate fsm get some functionality run it through that			//currstate needs work			//actor.UpdatePlacement(actor.moveVector);			if(actor.key.Y> 0){			actor.body.shapes.at(0).material.dynamicFriction=.0050			actor.body.allowRotation = false			}else{				actor.body.shapes.at(0).material.dynamicFriction=5				actor.body.allowRotation = true			}			// i like this its just very complex for unfinished code right now						//			if((actor.stuck || Math.abs(actor.body.velocity.x) < 300)&& !actor.coasting){//				actor.body.allowRotation = false//			}else{//				actor.body.allowRotation = true//					actor.coasting = true//			}//			//			if(Math.abs(actor.body.velocity.x) < 30)//			{//				actor.coasting = false//			}									//actor.MotorStateUpdate(actorPos);					}		//(Note): i think so far since that stuff worked what we want to do is actually test out th ray casting to see against a point i think i should be doing that in ground???!!? maybe im not sure		// then if i can get rid of some of the physics, just a real quick run through its huge change but im not sure its too much work ok lets get to it		/**		 * I used vector 3d but only cuz there is no vector 2d but it shouldnt matter honestly 		 * and it returns the value on u and then it return the value on t, i should of just done this 3D but i honestly		 * dont think it should matter, though remember to do x,z so you have to put in a new vector instead of just passing in the points		 */		public static function twodimlineIntersect(a:Vector3D,b:Vector3D, c:Vector3D, d:Vector3D):Array{		// get it in our additive vector form		var r:Vector3D = b.subtract(a)		var s:Vector3D = d.subtract(c);		// we use this again so only calc once		var div:Number = r.x * s.y - r.y * s.x; 		var u:Number = ((c.x - a.x) * r.y - (c.y - a.y) * r.x) / div;		var t:Number = ((c.x - a.x) * s.y - (c.y - a.y) * s.x) / div;				// if they do intersect return where			return [u,t]//(0 <= u and u <= 1 and 0 <= t and t <= 1) and a + t * r;		}		/**		 * takes screen x and y, and local z, then returns you its 3d point in space		 */		public static function Unproject(localV3:Vector3D,camra:Vector3D =  null,camrarot:Vector3D = null):Vector3D{						// i could do this cleaner but who cares			if(camra && camrarot){				//var M:Array = ZRot(camrarot.z*Math.PI/180)				var camMtrx:Array = m_Mult(m_Mult(ZRot(camrarot.z*Math.PI/180),YRot(camrarot.y*Math.PI/180)),XRot(camrarot.x*Math.PI/180))				var p:Vector3D = new Vector3D(camra.x,camra.y,camra.z)			}else{				camrarot = new Vector3D(LevelEditor.awyCam.rotationX, LevelEditor.awyCam.rotationY, LevelEditor.awyCam.rotationZ)				camMtrx = m_Mult(m_Mult(ZRot(camrarot.z*Math.PI/180),YRot(camrarot.y*Math.PI/180)),XRot(camrarot.x*Math.PI/180))				p = new Vector3D(LevelEditor.awyCam.x, LevelEditor.awyCam.y,LevelEditor.awyCam.z)			}			//NOTE(JON) disconnect away3d entirely eventually this is only for the Editor crap 			var ca:Vector3D  = new Vector3D()			var c:Vector3D = localV3			ca.x = -(c.x - vpX)*(fl - c.z)/fl			ca.y = -(c.y - vpY)*(fl - c.z)/fl			ca.z = c.z			return m_MultP(Translate(camMtrx,p),ca)		}						/**		 * takes a 3D coordinates and returns the 2D screenspace coordinate i thought why not give you the distance to the camera as well		 */		public static function project(realV3:Vector3D):Vector3D{						//NOTE(JON) disconnect away3d entirely eventually this is only for the Editor crap 			var p:Vector3D = new Vector3D(LevelEditor.awyCam.x, LevelEditor.awyCam.y,LevelEditor.awyCam.z)			var c:Vector3D = m_MultP(CameraTransform(getCol(cameraMtrx,0),getCol(cameraMtrx,1),getCol(cameraMtrx,2),p),new Vector3D(realV3.x, realV3.y,realV3.z))						var cl:Vector3D = new Vector3D()			 cl.x = c.x*fl/(c.z- fl)+vpX			 cl.y = c.y*fl/(c.z - fl)+ vpY			 cl.z = c.z			 return cl		}				public static function project2Point(localV3:Vector3D):Point{						//NOTE(JON) disconnect away3d entirely eventually this is only for the Editor crap 			var p:Vector3D = new Vector3D(LevelEditor.awyCam.x, LevelEditor.awyCam.y,LevelEditor.awyCam.z)			if(!cameraMtrx){			var camra:Object = {X:LevelEditor.awyCam.x,Y:LevelEditor.awyCam.y, Z:LevelEditor.awyCam.z,rotation:{x:LevelEditor.awyCam.rotationX,y:LevelEditor.awyCam.rotationY, z:LevelEditor.awyCam.rotationZ},fl:200}						var M:Array = ZRot(camra.rotation.z*Math.PI/180)			// I should save this so i dont have to keep doing it over and over again, those sines and cosines and whatnots			M = m_Mult(m_Mult(M,YRot(camra.rotation.y*Math.PI/180)),XRot(camra.rotation.x*Math.PI/180))			cameraMtrx = M			}			var c:Vector3D = m_MultP(CameraTransform(getCol(cameraMtrx,0),getCol(cameraMtrx,1),getCol(cameraMtrx,2),p),new Vector3D(localV3.x, localV3.y,localV3.z))						var cl:Point = new Point()			cl.x = c.x*fl/(c.z- fl)+vpX			cl.y = c.y*fl/(c.z - fl)+ vpY			return cl		}				/** must be careful when using this make sure you have		 * an x,y,z and a X Y Z basically its a display object but it needs those to check		 * */		public static function UpdateZDepth(cl:Object, ignoreVP:Boolean = true):void
		{						var camra:Object = {X:LevelEditor.awyCam.x,Y:LevelEditor.awyCam.y, Z:LevelEditor.awyCam.z,rotation:{x:LevelEditor.awyCam.rotationX,y:LevelEditor.awyCam.rotationY, z:LevelEditor.awyCam.rotationZ},fl:200}						var M:Array = ZRot(camra.rotation.z*Math.PI/180)			// I should save this so i dont have to keep doing it over and over again, those sines and cosines and whatnots			M = m_Mult(m_Mult(M,YRot(camra.rotation.y*Math.PI/180)),XRot(camra.rotation.x*Math.PI/180))			cameraMtrx = M			// i dunno if this is necessary but you pass the values of the object the real coordinates			var v:Vector3D = new Vector3D(cl.X,cl.Y,cl.Z)			// i dunno what i wrote before but what this is that it is the basic transforms that you pass to the camera transform			var p:Vector3D = new Vector3D(camra.X,camra.Y,camra.Z)						var c:Vector3D = m_MultP(CameraTransform(getCol(M,0),getCol(M,1),getCol(M,2),p),v)						// cl clearly represents whatever im trying to move around i think i may have actually used an object to use anything sooo yeah 			camra.fl = fl			if(c.z - camra.fl >=0){							}else{				cl.alpha = 0			}											if(c.z >= camra.fl){							var scale:Number = camra.fl/(c.z - camra.fl)			cl.fkalpha = cl.oldAlpha			cl.scaleX = scale*cl.scaleZ;			cl.scaleY = scale*cl.scaleZ;						if(cl is NSprite && c.z >= 4000){				cl.scaleX = .1				cl.scaleY = .1			}						cl.x = c.x*camra.fl/(c.z- camra.fl)+vpX			cl.y = c.y*camra.fl/(c.z - camra.fl)+ vpY			cl.zp = c.z			cl.rotation = -camra.rotation.z						}else{			cl.fkalpha = 0			cl.scaleX = .0001			cl.scaleY = .0001			}
		}		/**		 * It may be lack of sleep but its pretty easy what this does, it takes a 2d quardanit "pt".. whatever		 * and places an object that uses a 3D coordinate at the relative position in most cases a mouse cursor		 * you also have the option to set an offset 		 		 * */		public static function relativeXY( pt:Point,a:GeneralMotor, dx:Number = 0, dy:Number =0):void		{					// a lot of this stuff doesnt have rotating the camera ever but i don't think ill need it, and ill add it if i do.. whatevs			// this would fail on rotation 			var pscale:Number = fl/(a.Z - (fl +cameraZ));						a.scaleX = pscale;			a.scaleY = pscale;						a.X = pt.x*pscale +vpX 			a.Y = pt.y*pscale +vpY 						}		/**		 *The function tells you what the point's coordinates are, for a given z 		 * translated to a 3d plane		 */		public static function relativeXYZ( pt:Point,z:Number):Vector3D		{ 			// a lot of this stuff doesnt have rotating the camera ever but i don't think ill need it, and ill add it if i do.. whatevs			var scale:Number = fl/(z - (fl +cameraZ));			var a:Vector3D = new Vector3D()			a.x = (pt.x -vpX)/scale+vpX			a.y = (pt.y -vpY)/scale+vpY			a.z = z;			return  a		}		//if we know its xy and we want to figure out where the z is		// we have to flatten the line take our x, or y whatever and see how far were in		// so we take a vector use the vpx		/**		 * returns a Z depth for a given 3d X value, so it says using the literal x		 * the z would be here for to create the point at the literal x		 */		public static function relativeZfromx(pt:Point, X:Number):Number		{			// jeez thats really clever jon			// basically i said i know the vanishing point is at the center , but nothing will ever be at the center, it will only be constantly approaching the center, so the ratio of the horizontal or even vertical distance from the vanishing point over the X distance from the vanishing point, we should get  			//			// s is scale incase you forget			var s:Number = (pt.x - vpX)/(X - vpX);			// might wanna check math on this but it should be fine			return fl/s + cameraZ - fl		}		// FUTURE!!!!!		public static function XYStarling2DTranslation(a:starling.display.Sprite, pt:Point, dx:Number = 0, dy:Number =0):Point		{			// a lot of this stuff doesnt have rotating the camera ever but i don't think ill need it, and ill add it if i do.. whatevs			//var scale:Number = fl/(fl +(a.z - cameraZ));			//new Point((pt.x -vpX)/scale +vpX + dx,((pt.y -vpY)/scale +vpY + dy));			return null//new Point((pt.x -vpX)/scale +vpX + dx,((pt.y -vpY)/scale +vpY + dy));		}		/**		 * same as local3d to global im dumb		 */		public static function XYFlash2DTranslation(a:flash.display.Sprite, pt:Point = null, dx:Number = 0, dy:Number =0):Point		{			// a lot of this stuff doesnt have rotating the camera ever but i don't think ill need it, and ill add it if i do.. whatevs			var scale:Number = fl/(fl +(a.z - cameraZ));			//a.X = (pt.x -vpX)/scale +vpX + dx			//a.Y = (pt.y -vpY)/scale +vpY + dy										if(pt == null)			return new Point((a.x -vpX)/scale +vpX + dx,(a.y -vpY)/scale +vpY + dy)			else			return new Point((pt.x -vpX)/scale +vpX + dx,(pt.y -vpY)/scale +vpY + dy)		}						/** the points require having an X and a Y**/		public function angleBetweenpts(point1:Object, point2:Object,inDegrees:Boolean = true):Number		{			var dy:Number = point2.Y - point1.Y ;			var dx:Number = point2.X - point1.X;			if(inDegrees)			return Math.atan2(dy, dx)* 180/Math.PI			else			return Math.atan2(dy, dx)		}		// funny enough this would work very well except the private part this needs to be open, incase i feel like being lazy and putting the animation part here, Im really reconsidering the parting the animation and physics model		public function homingAttack(actor:GeneralActor, angle:Number, speed:Number):void		{//			////trace("jgf  hgjg kkkgk gjkh jhuygg kh o jgf  hgjg kkkgk gjkh jhuygg kh ojgf  hgjg kkkgk gjkh jhuygg kh ojgf  hgjg kkkgk gjkh jhuygg kh ojgf  hgjg kkkgk gjkh jhuygg kh o");			// this should be an air state, we'll put these all in an array so i don't have to check for each acrobatic move			// basically Im saying these all come back to the ground with the same animation unless i decide to get fancy lata			//if(angle == Number(null)){						if(!Hero(actor).closestConcern.body ||Hero(actor).closestConcern.distToSonic > 400)			{				if(actor.moveVector.X>=0)				actor.target.X = actor.X + 200;				else					actor.target.X = actor.x - 400;								actor.target.Y = actor.Y + 50									var dy:Number =  actor.target.Y- actor.Y;			var dx:Number = actor.target.X - actor.X;			angle =Math.atan2(dy, dx);					//	}//			////trace(angle);		// it basically just sends a burst and an animation			// youu play this for like a few set frames		// this is why i do animations different place though because here i call the animation just once, at the beginning and dont wanna get it mixed up		//actor.moveVector.X = Math.cos(angle) *(speed);		//actor.gv.Y = Math.sin(angle)*speed;		actor.body.applyImpulse(Vec2.get(Math.cos(angle)*(speed), Math.sin(angle)*speed));			// basically all this is it throws the object in a direction			// so yeah just fires an object in a direction similar to jumping		}else{//			if(Assets.RandomIntRange(3) == 2){//			Hero(actor).closestConcern.blocking= true;//			}			if(!Baddie(Hero(actor).closestConcern).thrown){			// do a while an angle and once we hit then we are happy			actor.body.velocity.setxy(0,0);						// You have to check if closest concern doesnt exist , 						if(actor.body.position.x < Hero(actor).closestConcern.body.position.x){				actor.body.position.setxy(Hero(actor).closestConcern.body.position.x-Hero(actor).closestConcern.width,Hero(actor).closestConcern.body.position.y);				actor.body.velocity.setxy(-200,300);			}else{				actor.body.position.setxy(Hero(actor).closestConcern.body.position.x+Hero(actor).closestConcern.width,Hero(actor).closestConcern.body.position.y);				actor.body.velocity.setxy(200, 300)			}//			Vec2.//			while(!actor.hitTestObject(Hero(actor).closestConcern)){//				//			}					// so how i could fix it somehow						if(!Hero(actor).closestConcern.blocking){			Hero(actor).closestConcern.Destroy()			}			Hero(actor).doublejumped = false;						}			}			Hero(actor).hanging = false;				}				public function additionalForces(cam:MainStage):void		{			//mouseJoint.active = true;//			if(cam.armature != null && cam.handR != null){//			// its basically test code to see if i can get the big baddie throwing sonic////			////trace("this is the x local",cam.armatureClip.x);//			if(cam.hero_mc.DistToPointXY(cam.armatureClip.x, cam.armatureClip.y) < 400 ){//			handJoint.body2= cam.hero_mc.body;//			//handJoint.anchor2.setxy(0,0);//			if(!armaplaying && cam.armature != null){//				cam.armature.animation.gotoAndPlay("throw");//				armaplaying = true;//				handJoint.active = true;//			}////			// Enable hand joint!//			//			}//			//			if (handJoint.active) {//				handJoint.anchor1.setxy(cam.armatureClip.x+cam.handR.global.x, cam.armatureClip.y+cam.handR.global.y);//			}//			if(cam.armature.animation.isComplete){//				handJoint.active = false;//			}//			}		}		// this is a bit of a mess and i dunno if im gonna keep this but i don't want this in general since it only works with hero, at least i think i need to check how i did the car things and baddies		// if not that shit needs to be cleaned up		public function calculateHeroAngle(hero:Hero):Number		{			return angleBetweenpts(new Vector3(floor.p1.X,floor.p1.Y,floor.p1.Z),new Vector3(floor.p2.X,floor.p2.Y,floor.p2.Z))				 		}				public function ground(actrX:Number):void		{			////trace("the ground is at: ", floor.Groundforce(hero));			////trace(actor.body.position.x, "h all the time")			//floor.GroundShape(actrX,floorBody)						 //			floorBody.shapes.remove(floorBody.shapes.at(0));//			floorBody.shapes.add(new Polygon(floor.GroundShape(actor.body.position.x)[0]));//			}						var grndedY:Number = floor.GroundY(actrX);			var forceGround:Boolean = false			if(Main.liveCamera.hero_mc.bdy.y <=grndedY || forceGround)			{							Main.liveCamera.hero_mc.bdy.y = grndedY			// hmm i dont know if i wanna use this becaue is grounded is more of a umm tenative idea						// for the loop deloop ill simply force it to stick to the ground						Main.liveCamera.hero_mc.isGrounded = true;			}else{				Main.liveCamera.hero_mc.isGrounded = false;			}//				//			//trace(actrX,"v ", Main.liveCamera.hero_mc.Z)			//				//hero.Y = 0;//			//	Slope(hero);//			}else{//				actor.isGrounded = false;//			}				//return actor.isGrounded;		//	////trace(motorHero.isGrounded);		}						public function Jump(actor:GeneralActor):void		{			//actor.gv.Y += js;			if (actor.isGrounded) 
			{
			pressedJump	= false; 
						if (!pressedJump) 
			{
			
			//now this part isnt as straightforward so ill explain what im doing determining our coordinate so i can jump perpindicular the normal or just up if were not moving, i could get the slope get the perpindicualar normal of that, or not				if (false) 
				{//			if(actor.body.velocity.x > .05){//				//				var j:Vec2 = actor.body.velocity.perp(true).normalise();//			actor.body.applyImpulse(j.mul(700));//			}else if(actor.body.velocity.x < 0){//				var t:Vec2 = actor.body.velocity.perp(true).normalise();//			actor.body.applyImpulse(t.mul(700));//			}else{//				if (actor.body.velocity.y > 0) 
//					actor.body.applyImpulse(Vec2.get(700,0));//				else if(actor.body.velocity.y < 0)//					actor.body.applyImpulse(Vec2.get(-700,0));//				//			}			}else{												actor.body.applyImpulse(Vec2.get(0,600),null,true)					// i need to do this little bit to wake it from sleeping i dunno why but there it is				if(actor.body.isSleeping)					actor.body.velocity.x = .00001;			}						pressedJump = true;			//heroBody.applyImpulse(new Vec2(0, -200));			}			}else{				// i dont think thisll get called i believe i did checks so it wont ger called multiple times but i can use as prototype				// and move this to float				actor.body.applyImpulse(Vec2.get(0, -200));							}		}		public static function local3DToGlobal(v:Vector3D):Point		{			// again if i ever want rotation, but honestly im treating this like an animation so thats a lil advanced and completely unnecessary for now			var scale:Number = fl/(fl +(v.z - cameraZ));						return new Point(vpX + (v.x - vpX)*scale,vpY + (v.y - vpY)*scale);		}				public function UpdatePhysicsActor(actor:GeneralActor):void		{			 			//actor.body.userData.graphic.isGrounded = true;			if(actor.body != null){				if(actor.inAlter){															Main.liveCamera.hero_mc.updateZdepth = false					if(floorBody.shapes.length>0)					floorBody.shapes.clear()					//actor.body.userData.graphic.Y = actor.prxy.Y//actor.body.position.y;//			//actor.body.userData.graphic.X = actor.body.position.x;//			floor.SnapToPathXZ(actor, actor.prxy.X)//actor.body.position.x);//			actor.body.userData.graphic.rotation = actor.body.rotation;//			if(actor.gv.Y < 30)				}else{ 										actor.Y = actor.bdy.y;										//actor.body.userData.graphic.X = actor.body.position.x;					floor.SnapToPathXZ(actor,actor.bdy.x);					//actor.Y +=1					Main.liveCamera.hero_mc.updateZdepth = true					// here isnt  where we would use the image proxy for certain movements if i wasnt lazy i would use it in the two classes					// that don't rely on the body 				}//			actor.gv.Y += gravity//			//			hero.Y 			}					}		//		protected function Slope(hero:Vector3):Vector3		//		{			//			scale = floor.slope/90;//			slope.Y = Math.abs(scale)*gravity;//			//			slope.X = Math.tan(floor.slope)/gravity;//			//		return slope;	//	}								// we need this		public static function XRot(angle:Number):Array		{			var c:Number = Math.cos(angle)			var s:Number = Math.sin(angle)						var R:Array = [[1, 0,0,0],				[0, c,s,0],				[0, -s,c,0],				[0,0,0, 1]]			return R					}				public static function YRot(angle:Number):Array		{			var c:Number  = Math.cos(angle)			var s:Number = Math.sin(angle)						var R:Array = [[ c,0,s,0],				[ 0,1,0,0],				[-s,0,c,0],				[ 0,0,0,1]]			return R					}				public static  function ZRot(angle:Number):Array		{			var c:Number = Math.cos(angle)			var s:Number = Math.sin(angle)						var R:Array = [[c,-s,0,0],				[s, c,0,0],				[0, 0,1,0],				[0, 0,0,1]]			return R					}				private static function identity():Array		{									var R:Array = [[1,0,0,0],				[0,1,0,0],				[0,0,1,0],				[0,0,0,1]]			return R					}				private static function Columns3x3(X:Vector3D,Y:Vector3D,Z:Vector3D):Array		{						var R:Array = [[X.x,Y.x,Z.x,0],				[X.y,Y.y,Z.y,0],				[X.z,Y.z,Z.z,0],				[0,  0,  0,  1]]			return R					}						private static function Rows3x3(X:Vector3D,Y:Vector3D,Z:Vector3D):Array		{						var R:Array = [[X.x,X.y,X.z,0],				[Y.x,Y.y,Y.z,0],				[Z.x,Z.y,Z.z,0],				[0,  0,  0,  1]]			return R					}				private static function getCol( mtrx:Array, c:int):Vector3D		{			var R:Vector3D = new Vector3D()			R.x = mtrx[0][c]			R.y = mtrx[1][c]			R.z = mtrx[2][c]			return R		}		// i dont use this but there may be a time that i need it 		private static function getRow( mtrx:Array, r:int):Vector3D		{			var R:Vector3D = new Vector3D()			R.x = mtrx[r][0]			R.y = mtrx[r][1]			R.z = mtrx[r][2]			return R		}		/**		 * this takes the rows of a matrix represented by the X vector Y vector, and the Z vector, then transposes its the rotations that its transposing/inverting then		 * it subtracts the movements represented by P		 */		private static function CameraTransform(X:Vector3D,Y:Vector3D,Z:Vector3D, P:Vector3D):Array{			var R:Array = Rows3x3(X,Y,Z);			R = Translate(R, neg(m_MultP(R,P)))			return R		}		// this is the negative solver 		private static function neg(V:Vector3D):Vector3D{			var R:Vector3D = new Vector3D()			R.x = V.x *-1			R.y = V.y *-1			R.z = V.z *-1			return R		}		// m_Mult verry verry imporant		private static function m_MultP(A:Array, P:Vector3D, Pw:Number = 1):Vector3D		{			var R:Vector3D =new Vector3D()			R.x = P.x*A[0][0]+P.y*A[0][1]+P.z*A[0][2]+Pw*A[0][3];			R.y = P.x*A[1][0]+P.y*A[1][1]+P.z*A[1][2]+Pw*A[1][3];			R.z = P.x*A[2][0]+P.y*A[2][1]+P.z*A[2][2]+Pw*A[2][3];						return R;					}				// also very important		public static function Translate(A:Array, T:Vector3D):Array		{			var R:Array = A;			R[0][3] += T.x;			R[1][3] += T.y;			R[2][3] += T.z;			return R;		}		// Extremely important		public static function m_Mult(a:Array, b:Array):Array		{			var R:Array = [[],[],[],[]]						for( var r:int = 0; r<=3; r++){// this is the rows of A				for(var c:int= 0; c<=3; c++){ // these are the culumns of B					R[r][c] = 0					for(var i:int = 0; i<=3; i++){ // this is the column of a, rows of B						R[r][c] += a[r][i]*b[i][c]					}				}			}			return R		}		public function ProcessCameraMotion(cam:MainStage):void		{										}		public function get currState():String		{			return _currState;		}		public function set currState(value:String):void		{			_currState = value;		}		public function get gravity():Number		{			return _gravity;		}		public function set gravity(value:Number):void		{			_gravity = value;		}		public function get motorHero():Hero		{			return _motorHero;		}				public function set motorHero(value:Hero):void		{			_motorHero = value;		}				public function get js():Number		{			return _js;		}				public function set js(value:Number):void		{			_js = value;		}			}}