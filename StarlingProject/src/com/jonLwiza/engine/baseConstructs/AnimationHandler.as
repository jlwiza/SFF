package com.jonLwiza.engine.baseConstructs{	import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.actors.Hero;	import com.jonLwiza.engine.helperTypes.Anim;	import com.jonLwiza.engine.helperTypes.Status;		import flash.display3D.textures.Texture;	import flash.utils.Dictionary;		import starling.core.Starling;	import starling.display.MovieClip;	import starling.display.Sprite;	import starling.textures.Texture;
	// **needs fixing **/	public class AnimationHandler extends GeneralSound	{		private var _playing:Boolean = true;		private var _movie:MovieClip;		private var currentlyplaying:String = "blink";		private var _trani:Boolean;		private var framesTransfer:Array = new Array();		private var endFrame:uint;		private var _frame:int;		private var ticker:int = 0;		private var curHAnimation:Array = new Array();		protected var _atlas:Array = new Array();				public var completeTweens:Array;		private var tweenset:Boolean = false;		public var parallelTweeens:Array = [];		public static var EDIT:Boolean = true;		private var tweenAnimation:String;		private var animationOnQue:String;		private var startFrame:*;		public var playedAnimations:Dictionary = new Dictionary();				// this would go in whatever object I want to test against		public var  animationAngles:Array  = [{anim:"standingAnim",angles:[0,25,45,90,120]}]		// we can do different ones like sonic animation or whatever but i think this should be fine		// i might need to clear it once in a while but it should be good		private var tweening:Boolean;		private var resultingAng:Number = 0;				public function AnimationHandler()		{			super();			// I dont think keeping something as big as backgrounds constantly in memory is a good thing			_atlas.push("SonicSa","testin","backgrnds","SpiritRuinAtlas","FinalCutAtlas");					// alright to handle animations around to but since this needs			// to keep it's place in time animating I'm just gonna sudo code the thing					}		// alot of this stuff is kinda deprecated as the way im doing it now, but since this shit is gonna be rewritten for starling really dont matter too much		// we call this to just query an new animation and updates it if were on the last frame or were on a frame that can be changed		//we'll use greensock, itd be more efficient		public function HardAnimations(animation:Array, bodyPart:Sprite, rootX:Number = 0, rootY:Number = 0,loop:Boolean = false, frame:int = -1):void		{						ticker++			if(curHAnimation != animation){				ticker = 0;				curHAnimation = animation;			}			if(ticker == animation.length)			{				if(loop)					ticker = 0;				else					return;			}						bodyPart.x = animation[ticker][0]+rootX;			bodyPart.y = animation[ticker][1]+rootY;			bodyPart.rotation = animation[ticker][2];		}		public function HardPtAnimations(animation:Array, bodyPartX:Number,  bodyPartY:Number, rootX:Number = 0, rootY:Number = 0,loop:Boolean = false, frame:int = -1):void		{						ticker++			if(curHAnimation != animation){				ticker = 0;				curHAnimation = animation;			}			if(ticker == animation.length)			{				if(loop)					ticker = 0;				else					return;			}						bodyPartX = animation[ticker][0]+rootX;			bodyPartY = animation[ticker][1]+rootY;		}				public function playAnimation(animation:String, changeAtFrame:Number = 0, looping:Boolean = false):String		{			throw Error("this function isnt ready yet")			var loc:int = 0			//STarling						//var texture:Texture = Texture.fromBitmap(new AtlasTexture());			//var xml:XML = XML(new AtlasXML());			// atlas:TextureAtlas = new TextureAtlas(texture, xml);						if(movie == null){								if(EDIT)				{																									if(playedAnimations[currentlyplaying] == undefined)					{						// the problem with these it just looks for the frames that are in atlases						for (loc = 0; loc < atlas.length; loc++) 
						{
							if(Assets.getAtlas(atlas[loc]).getTexture(currentlyplaying+"0000") != null)							break;															
						}
												if(Assets.getAtlas(atlas[loc]).getTexture(currentlyplaying+"0000") == null){							throw Error("could not find "+currentlyplaying+" in "+atlas[loc])						}												movie = new MovieClip(Assets.getAtlas(atlas[loc]).getTextures(currentlyplaying+"0"), 24);						playedAnimations[currentlyplaying] = movie;											}else{						// this is actually k						movie = playedAnimations[currentlyplaying];											}																			}else{				movie = new MovieClip(Assets.getAtlas(atlas[loc]).getTextures(currentlyplaying+"0"), 24);							}			}									frame = movie.currentFrame;						// Ill move this to the fsm			if(animation != currentlyplaying){																////trace("yjyh  hjgh j l l  HIYG fF   fg ",this.getChildByName("blink"));//			if(changeAtFrame == 0)//			{//				trani = movie.totalFrames;//			//			}else//			{//				trani = changeAtFrame;//			}//			for (var j:int = 0; j < 400; j++) //			{//			//trace(movie.totalFrames," ",movie.currentFrame);//			}			// find out whats playing//			if(animation.cutsIn)//				straightto(animation, looping);						if(movie.currentFrame >= trani)			{								//get code to code				 //"currentlyPlaying::animation.name"b					//					for (var i:int = 0; i < 400; i++) //			{//			//trace(animation, currentlyplaying)	//			}									//straightto(animation);												}			}else{				////trace(movie)								if (movie.currentFrame >= movie.numFrames - 1) 				{										if(looping){					//straightto(animation);					}else{					//movie.stop();					playing = false;					return Status.S_SUCCESS					}				}			}			return Status.S_RUNNING		}				public function straightto(anim:Object, loop:Boolean = false, start:int = -1):void		{									if(anim is String){				var animation:String = String(anim)			}else{								animation = anim.animation								//hmm im not sure how to do anim.loop so im just gonna leave it				if(anim.loop)					loop = anim.loop								if(anim.start)					start = anim.start											}						animation = animFacing(animation)			//			var loc:int = 0
			
			//	//trace("is this geting played?", animation);
			
									playing = true;			 				if(currentlyplaying != animation)				{				//gotoAndStop(animation);				currentlyplaying = animation;				movie.stop();								removeChild(movie,true);				starling.core.Starling.juggler.remove(movie);				if(EDIT)				{					var isInAtlas:Boolean = true																	// what is this? hmmm... i think i was, i think im creating a dictionary of played animations on the fly.. ok						if(playedAnimations[currentlyplaying] == undefined)						{							for (loc = 0; loc < atlas.length; loc++) 							{								if(Assets.getAtlas(atlas[loc]).getTexture(currentlyplaying+"0000") != null)									break;																							}							if(loc == atlas.length){								trace(atlas[loc-1]," ", currentlyplaying+"0001")								var errorMessage:String = currentlyplaying+" not found ::::we've exceeded the bounds of the atlas :::::"								trace(errorMessage)								isInAtlas = false							}							//trace(currentlyplaying)							// okay this is kinda rudimentary but um itll work to find the atlas the image is in							if(isInAtlas){							playedAnimations[currentlyplaying] = new MovieClip(Assets.getAtlas(atlas[loc]).getTextures(currentlyplaying+"0"), 24);							}else{																var res:Vector.<starling.textures.Texture> = new <starling.textures.Texture>[]								for(var i:int=1;Assets.isTextureLoaded(currentlyplaying,i);i++){									if(i < 10)										res.push(Assets.getTexture(currentlyplaying+"000"+i))									else										res.push(Assets.getTexture(currentlyplaying+"00"+i))																	}								if(!Assets.isTextureLoaded(currentlyplaying,1)){									errorMessage = currentlyplaying+" not found ::::we've exceeded the bounds of the atlas, and isnt in the game  :::::"									throw Error(errorMessage)								}								playedAnimations[currentlyplaying] = new MovieClip(res)							}						}						//if(this is Hero){							movie = playedAnimations[currentlyplaying]//						}else{//						for (loc = 0; loc < atlas.length; loc++) //						{//							if(Assets.getAtlas(atlas[loc]).getTexture(currentlyplaying+"0000") != null)//								break;//							//							//						}//						if(loc != atlas.length){//							//					movie = new MovieClip(Assets.getAtlas(atlas[loc]).getTextures(currentlyplaying+"0"), 24);//						}//						}//					if(GeneralActor(this) == xSheet.actor){//						xSheet.animation//						//var txt:Vector.<starling.textures.Texture> = new Vector.<Texture>;//						for (var i:int = 0; i < movie.numFrames; i++) //						{//							// we populate the txt texture vecture //							//txt.push(mc.getFrameTexture(i));//							// then add it to the animation list//							xSheet.animation.push({ text: (i+1).toString(), thumbnail: movie.getFrameTexture(i) })//						}//					}									}else{				if(loc != atlas.length){				movie = new MovieClip(Assets.getAtlas(atlas[loc]).getTextures(currentlyplaying+"0"), 24);				}else{					//hmm i wrote this so when it comes accross a texture that needs loading it loads it on the fly, which is insane					// this is dumb like very dumb but its good because it is dumb					var res:Vector.<starling.textures.Texture> = new <starling.textures.Texture>[]						// we can make it more dynamic and shorten load times by asking if is texture loaded is there that way i can						//also delete certain textures from the queue as well but i think it might be better to go sloppy to clean						// in this scenario						for(var i:int=0;Assets.isTextureLoaded(currentlyplaying,i);i++){							if(i < 10)							res.push(Assets.getTexture(currentlyplaying+"000"+i))							else							res.push(Assets.getTexture(currentlyplaying+"00"+i))						}											movie = new MovieClip(res)				}								////trace("name of the thing: "+currentlyplaying+" num of frames: "+movie.numFrames+" currentframe: "+movie.currentFrame);				}												movie.x = 0;				movie.y = 0;				movie.loop = false;				movie.alignPivot()				starling.core.Starling.juggler.add(movie);				addChild(movie);				movie.name = currentlyplaying				//trace(currentlyplaying)				// i think its here i put it				// crap this will work for one, but multiple watches have to be done similarly than combined												movie.play()				if(start >= 0){					movie.currentFrame = start;				}				if(EDIT)				{					// this seems dumb i dunno how i could then animate other things with this					// i think this may just be a reporter though so that i can grab the animation										Hero.Anim = playedAnimations[currentlyplaying]														}			}else{				if(movie.currentFrame == movie.numFrames-1)				movie.currentFrame = 0;			}											// TODO Auto Generated method stub			//just goto and play 				}		// i made no notes because i am a dumb face		private function animFacing(playingAnimation:String):String		{			for (var j:int = 0; j < animationAngles.length; j++) 
			{
				if(playingAnimation == animationAngles[j].anim)				{					break;				}					
			}
			if (j == animationAngles.length)				return playingAnimation				var animAngles:Array = animationAngles[j].angles			resultingAng = animAngles[0]			if(animAngles.length == 0){				return playingAnimation			}			for (var i:int = 1; i <animAngles; i++) 			{				if(Math.abs(resultingAng - facingAngle)  > Math.abs(animAngles[i] - facingAngle)){										resultingAng = animAngles[i]									}			}						return playingAnimation+resultingAng.toString();		}					// I think Animateto is just delayed animation till the other thing finishes animating		/** you can put a string or a object with the parameters loop and or start, using an object just makes it so each animation you send it works as a self contained mutable packet  **/		public function Animateto(anim:Object, loop:Boolean = false, start:int = -1):void		{						// I really dont like doing this but I think this is the only way  uggh this is so duuuummmbbbb 			if(anim is String){				var animation:String = String(anim)			}else{								animation = anim.animation									//hmm im not sure how to do anim.loop so im just gonna leave it				if(anim.loop)				loop = anim.loop									if(anim.start)				start = anim.start												}						animation = animFacing(animation)			////trace(currentlyplaying, " ", movie.currentFrame, " ", movie.numFrames -1)					if(GeneralActor(this).isWatched && !isFrozen ){				FrameHandler.Update()													if(!Main.Release){				if(GeneralActor(this) == xSheet.actor){					xSheet.animation.push({ text: (movie.name+movie.currentFrame).toString(), thumbnail: movie.getFrameTexture(movie.currentFrame) })						//var txt:Vector.<starling.textures.Texture> = new Vector.<Texture>;									}					}else{											}			}				if(!tweenset)				{					startFrame = start					animationOnQue = animation					endFrame = movie.numFrames-1						tweenAnimation = currentlyplaying +"TO"+animation;					for (var i:int = 0; i < completeTweens.length; i++) 					{						//this basically just tells it where it should finish playing if its not at the last frame						// its so it can be more responsive while me not having to make eight million animations						//keep in mind this doesnt change the animationTo name like ParallelAnimation does						if(tweenAnimation == completeTweens[i][0])						{							if(completeTweens[i].length > 1)							{								for (var j:int = 1; j < completeTweens[i].length; j++) 								{									if(movie.currentFrame < completeTweens[i][j])									{										endFrame = completeTweens[i][j];										tweenAnimation = currentlyplaying+endFrame.toString() +"TO"+animation;										break;									}								}															}							break;						}					}						if(startFrame >= 0){							// in theory what it was is its supposed to wait for points when it could switch to another animation and if it reached that you use the tween to do it							// we search the first part of the damn thing for parallel tweens							for (var i2:int = 0; i2 < parallelTweeens.length; i2++) 
							{
								if(tweenAnimation == parallelTweeens[i2][0])								{									if(parallelTweeens[i2].length > 1)									{										for (var j2:int = 1; j2 < parallelTweeens[i2].length; j2++) 										{											if(movie.currentFrame < parallelTweeens[i2][j2])											{												tweenAnimation = currentlyplaying +"TO"+animation+parallelTweeens[i2][j2].toString();												break;											}										}																			}									break;								}
							}
													}										// this if were tweenless we just default					if(i==completeTweens.length)					{					////trace("we gots no tween for "+currentlyplaying+"TO"+animation+" wwes just gonna default to "+animation);					// what this used to do was if there was no transitional animation, it would just go to the next animation on que without ending it					// not entirely sure why i thought that made sense but it utters most trani's useless, 					tweenAnimation = animation;					if(currentlyplaying != animation+"TO"+animation)					endFrame = movie.currentFrame;
					}else{						////trace("we gots a tween fo dat its called  "+tweenAnimation);					}					//we've basically set up the tween										tweenset= true;				} 				if(tweenset){////trace("name of the thing: "+currentlyplaying+" num of frames: "+movie.numFrames+" currentframe: "+movie.currentFrame+" end frame: "+endFrame);										if(movie.currentFrame >= endFrame)					{												////trace("this is what were caling to be animated "+tweenAnimation);						straightto(tweenAnimation,false, startFrame)						tweenset = false;						tweening = true;						startFrame = -1;					// basically if I have a new directive put that in the que instead, it may be unsafe there is a chance we might be in limbo but i think i need to check that elsewhere not here						}else if(animationOnQue !=animation)					{						// consider a cooldown where itd wait two frames before changng to prevent false data						animationOnQue =animation;						//same shit						endFrame = movie.numFrames-1						tweenAnimation = currentlyplaying +"TO"+animation;						for (var k:int = 0; k < completeTweens.length; k++) 						{							if(tweenAnimation == completeTweens[k][0])							{																if(completeTweens[k].length > 1)								{									for (var l:int = 1; l < completeTweens[k].length; l++) 									{										if(movie.currentFrame < completeTweens[k][l])										{											endFrame = completeTweens[k][l];											tweenAnimation = currentlyplaying+endFrame.toString()+"TO"+animation;											break;										}									}																	}								break;							}						}						if(startFrame >= 0){							// we search the first part of the damn thing for parallel tweens							for (var i3:int = 0; i3 < parallelTweeens.length; i3++) 							{								if(tweenAnimation == parallelTweeens[i3][0])								{									if(parallelTweeens[i3].length > 1)									{										for (var j3:int = 1; j3 < parallelTweeens[i3].length; j3++) 										{											if(movie.currentFrame < parallelTweeens[i3][j3])											{												tweenAnimation += parallelTweeens[i3][j3].toString();												break;											}										}																			}																		break;								}							}													}												// this if were tweenless we just default						if(k==completeTweens.length)						{							////trace("we gots no tween fo dat wwes just gonna default to "+animation);							tweenAnimation = animation;							if(currentlyplaying != animation+"TO"+animation)								straightto(animation,loop, start)								//endFrame = movie.currentFrame;						}										}									}														}						public function get movie():MovieClip		{			return _movie;		}		public function set movie(value:MovieClip):void		{			_movie = value;		}		public function get trani():Boolean		{			return _trani;		}		public function set trani(value:Boolean):void		{			_trani = value;		}		public function get playing():Boolean
		{
			return _playing;
		}		public function set playing(value:Boolean):void
		{
			_playing = value;
		}		public function get frame():int
		{
			return _frame;
		}		public function set frame(value:int):void
		{
			_frame = value;
		}		public function get atlas():Array
		{
			return _atlas;
		}		public function set atlas(value:Array):void
		{
			_atlas = value;
		}							}}