package com.jonLwiza.engine.GeneralElements{	import com.jonLwiza.engine.actors.Hero;	import com.jonLwiza.engine.actors.Hornet;	import com.jonLwiza.engine.actors.MainStage;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.helperTypes.Status;	import com.jonLwiza.engine.state.GroupBehavior;
			// this functions more or less as the brains or the real director it would make sense to reroute things to this and rename it accordingly, but i think it make give me some freedom i dont yet see if i leave it like this	//since group dynamics has to extend a general actor to work, we might as well play the cutscenes on it	public class GroupDynamix extends GeneralActor	{		private var _closestBaddie:Baddie;		private var groupBehavior:GroupBehavior = new GroupBehavior();		private var currBaddies:Array = new Array();		private var hero:Hero;		private var localBaddies:Array = new Array();		private var attacker:Baddie;		private var tick:int = 0;		private var targetNum:int = 0;		private var ticker:int;		private var pacing:int;		private var nonWorkingBaddies:Vector.<Baddie> = new Vector.<Baddie>();		private var _active:Boolean = true;						public function GroupDynamix()		{			super();			motorBTree = groupBehavior;			groupBehavior.actor = this;						tick = 0;		}		public function initialize(hero:Hero, baddies:Array):void		{			this.hero = hero;			this.hero.localBaddies = baddies				closestBaddie = null				nonWorkingBaddies.length = 0;		}		// create an instance of this class on main and call this Update function		// putting camera to null for now cuz i am not wanting to deal with that right now		// this mirrors how most things should be set up in the main thingy thingy so thaty are updated correctly 		override public function Update(hero:Object = null):void		{						this.hero = Hero(hero)			// return the state its in			// umm whatever I'll put this here cuz I have no I dea what the rest of this stuff is doing						if(this.hero.isJumping && this.hero.closestConcern)			{				this.hero.closestConcern.filter = this.hero.closestConcern.myFilter			}else{				if(!this.hero.hanging){				this.hero.closestConcern.filter = null				}			}							// we bring those two in cuz they are the two most general places we'll probably attach ourselves too them, thats it really I dont even have to do the update every frame 			//UpdateBtrees();				if(active){			UpdateUPC();				}			//return currMBehaviour		}				public function UpdateUPC():Number		{						// return just the number of badguys I dont care about the number of other elements if Im not focused on just the one, there should be some scene overide to take over it						// discern who the closest badguy is and generalize the others and put them into section for more advanced like behaviour						// i need to use some sort of haha, sorting algorithms because checking against every baddie would take up quadratic time, but for now, fudge it						//Basically This is the brains behind how the thing knows when to attack, as not to get cluttered, and also give me control			// it basically says lets choose a closest baddie, check then when the time of the pace we tell it to attack						if(closestBaddie == null){				if(hero.localBaddies.length < 1){					for (var k:int = 0; k < nonWorkingBaddies.length; k++) 					{						if(k<0)							k = 0;						Baddie(nonWorkingBaddies[k]).canAttack = true;						hero.localBaddies.push(nonWorkingBaddies[k]);						nonWorkingBaddies.splice(k,1);						if(nonWorkingBaddies.length >0)							k-=2;					}														}else{					for(var n:int = 0; n<nonWorkingBaddies.length; n++)					{						if(n<0)							n = 0;						if(nonWorkingBaddies[n].canAttack){														hero.localBaddies.push(nonWorkingBaddies[n]);							nonWorkingBaddies.splice(n,1);							if(nonWorkingBaddies.length >0)								n-=2;						}					}				}				for (var i:int = 0; i < hero.localBaddies.length; i++) 				{										if(i<0)						i = 0;					if(i == 0 ){						closestBaddie = hero.localBaddies[0]					}					if(closestBaddie.attacking)						//trace("something");					if(!Baddie(hero.localBaddies[i]).canAttack){												// we take this away so itll attack multiple times						nonWorkingBaddies.push(hero.localBaddies[i])						hero.localBaddies.splice(i,1);						if(hero.localBaddies.length >1)							i-=2;					}else{						if(closestBaddie.distToSonic == 0){							closestBaddie.UpdateDistToSonic()							for (var j:int = 0; j < hero.localBaddies.length; j++) 							{								Baddie(hero.localBaddies[i]).UpdateDistToSonic()							}						}																		if(closestBaddie.distToSonic > Baddie(hero.localBaddies[i]).distToSonic){														closestBaddie = hero.localBaddies[i]													}					}				}															}else{				// now were gonna want to be able to customize the pace not only for each baddie				// but the overall pace				////trace(hero.closestConcern.distToSonic, " ? ",closestBaddie.distToSonic);				//				if(hero.closestConcern != closestBaddie)				//				hero.closestConcern = closestBaddie;				if(ticker > pacing)					Fight();				else					ticker++											}			// basically it says temporarily use these baddies and dont care about the one attacking for now			//localBaddies = others;															return 1;					}				public function get closestBaddie():Baddie		{			return _closestBaddie;		}				public function set closestBaddie(value:Baddie):void		{			_closestBaddie = value;		}						public function Fight():String		{						//KISS STUPID			// instead were gonna geet rid of the splicing then were gonna ask it if it can Attack			// then we do						////trace(closestBaddie.distToSonic, " < ",closestBaddie.comfortZone," ",attacker);			// remember spot is supposed to do most of this for a more life like feel but for now if we do it like this we turn it straight into the figt			if(closestBaddie.distToSonic < closestBaddie.comfortZone && attacker == null && closestBaddie.canAttack){				//baddigroup()				// were gonna say for right now the closest one is gonna be attacking								closestBaddie.attackingState = true;				attacker = closestBaddie 				closestBaddie = null;								// i tried doing two different things simultaneously i dont know why 				//localBaddies[randomWholeNumberRange(localBaddies.length - 1)] = attacker;				//attacker.attacking = true;				tick = 0;				targetNum = randomIntRange(45,80);				timeToNextAttack()				return Status.S_RUNNING				// it should really just pick one to attack I'm not too conserned about its distance and the baddie itself should ask sonic are you being attacked by seeing if it has an attacker				// then the attacked thing should send out a signal to this saying he's, and some info been attacked, which in turn sets up a ticker, you know this is easier and better so im just gonna do this				// and this thing listens to see if the ticker has been set up, dont send 				//basically go through each of the baddies in the array and puts the next one on query ready to attack, recieves attack que, checks if its dead before, we'll add some dead times and what not, probably in just update clicks			}else if(closestBaddie.distToSonic < closestBaddie.comfortZone && attacker != null){					//				if(!attacker.attacking && !queed.attacking)				//				attacker = null				timeToNextAttack();				//AnimationStateUpdate("ani",false,true);				return Status.S_RUNNING			}else{								//if this works it simply says there should be a wait time before doing the whole entire loop over all the elements, so as to not over exert it				// i really dont need to do this since im never gonna look through all the elements except in testing like this				closestBaddie = null;								return Status.S_RUNNING			}			//return Status.S_INVALId		}				private function timeToNextAttack():void		{			tick++			if(localBaddies == null){				attacker = null;								return			}			if(tick >=targetNum){				//this could work but its stupidly convoluted and i dont know why				//hero.localBaddies[randomWholeNumberRange(localBaddies.length - 1)] = attacker;				//attacker.attacking = true;				attacker = null				tick = 0;				targetNum = randomIntRange(45,80);			}						// TODO Auto Generated method stub					}				private function BadGroup():void		{					}		private function BaddiGroup():void		{			// this gets called once on the meet or spot function, so we know the initial size, and wanna seperate them into subsidiery groups by naming them, in different roles			// since this is a really cool function route this through the main scene so I can fuck with it myself			// this doesnt keep track of the number of them too much fight does that and can change em at will			//so i can call one of them at random from a pre made group to do special interactions with			// will have like things that will do stuff basi		}		public function get active():Boolean
		{
			return _active;
		}		public function set active(value:Boolean):void
		{
			_active = value;
		}			}}

