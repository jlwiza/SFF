package com.jonLwiza.engine.actors{	import com.jonLwiza.engine.GeneralElements.ClimableBlock;	import com.jonLwiza.engine.GeneralElements.MotorAnimations;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.helperTypes.Status;	import com.jonLwiza.engine.state.MessBossBehavior;		import starling.core.Starling;	import starling.display.MovieClip;	import starling.display.Sprite;	import starling.events.Event;
	// should rename to mess boss	public class BaddieBoss extends Hornet	{	private var animations:MotorAnimations = new MotorAnimations();			private var ticker:int = 0;			private var curAnimation:Array = new Array();			private var messBossBehavior:MessBossBehavior = new MessBossBehavior();			private var rightArm:ClimableBlock;			private var leftArm:ClimableBlock;			private var holding:Array = new Array();			private var bossThrowing:Array = new Array();			private var diving:Array = new Array();			private var bDiving:Array = new Array();			private var timeTocanAttack:int = 0;			private var bossThrow:Boolean = false;			private var bossHold:Boolean = false;			private var bossDive:Boolean = false;			private var bossSlapping:Boolean = false;			private var started:Boolean =false;			private var currAttack:int = 0;			private var currAttkDist:Number;			private var attackList:Array;			private var maxDist:Number = 7500;			private var spaceCount:int;			private var armaplaying:Boolean = false;			 		public function BaddieBoss()		{			super("BigBaddie");						atlas.push("BigBaddie");						// make sure if you move the baddie around, move his body parts too			addEventListener(Event.ADDED_TO_STAGE, allLoaded);					}						protected function allLoaded(event:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, allLoaded)			attackList = [[1000,bossHold],[500,bossThrow],[1200,bossSlapping],[2000,bossDive]]			comfortZone = height - 220;;			motorBTree = messBossBehavior;			messBossBehavior.actor = this;			leftArm = ClimableBlock(this.parent.getChildByName("leftArm_mc"));			rightArm = ClimableBlock(this.parent.getChildByName("rightArm_mc"));					}								// so now its pretty easy just hook up the behavior like usual and then tag on some of these animations, 		//the ultra cool thing about this too is you can alter this code to be like an influencer, if you have like a missile going crazy or whatever				// for now dont worry about tweensto's it gets complicated, so right now just do loops and whatnot, and we'll hardcode things like if it loops		// havent made body part yet, we'll just make it a sprite right now for testing//		public function HardAnimations(animation:Array, bodyPart:Sprite,loop:Boolean = false, frame:int = -1)//		{//			if(curAnimation != animation){//				ticker = 0;//			curAnimation = animation;//			}//			if(ticker == animation.length)//			{//				if(loop)//					ticker = 0;//				else//					return;//			}						// okay im leaving the frame there as a pop to frame kinda thing for now doesnt really do anything			//			bodyPart.x = animation[ticker][0];//			bodyPart.y = animation[ticker][1];//			bodyPart.rotation = animation[ticker][2];//			//		}		private function pursue(anim:String):void{				if(hero.x > this.x -4)				{					this.x+= 10															//				for each (var part:Sprite in messBossParts) 					//				{					//					part+= 10					//					HardAnimations(animations.moveLeft, part, true)					//				}					//HardAnimations(moveLeft,leftArm);					//HardAnimations(moveLeft,rightArm);																								}else if(hero.x < this.x){				// in the final just move the whole mess boss						this.x-= 6;										//				for each (var part:Sprite in messBossParts) 					//				{					//				   part -=6;					//					HardAnimations(animations.moveRight, part, true)					//				}										//HardAnimations(moveRight,leftArm);					//HardAnimations(moveRight,rightArm);														}							UpdateDistToSonic();		}		// this is the temp so i dont have to do any work		override protected function wait():void		{			UpdateDistToSonic();			////trace(distToSonic);			if(justAttacked){				timeTocanAttack = waitTime;				justAttacked = false;			}			if(timeTocanAttack > 0)				timeTocanAttack--;			else				canAttack = true;		}				public function BBossThrowing(anim:String):String		{			if(bossThrow){			// its more of a movie				hero.gv.Y = 45;								// we implement a jumo to other points after this it'll also help control thing like hangtime				//trace("ME TOO HOMBRE")				hero.moveVector.X = 25;								if(hero.isGrounded)					bossThrow = false;			//HardAnimations(bossThrowing, hero, this.x, this.y);			return AnimationStateUpdate(anim, false, false);		}else{			return Status.S_FAILURE		}		}				public function BBossHolding(anim:String):String		{			if(bossHold){			//trace("ME TOO HOMBRE")			if(!hero.taunting){			if(hero.spacebar)				spaceCount++								if(false){//spaceCount < 1){								//			hero.x = this.x;//			hero.y = this.y;			}else{				//play some get out of holding animation				//this is also where we might decide to get out of hold				bossHold = false;				//at this point targeting recticle pops up and youll probably end up climbing up near the tail to hit him				//and as long as long as you can grab on animation should do the rest I may put some hard animations to help it through too 			}				// do the same to diving first expand the animation so that it goes longer or loop it i really dont care				// second 			//HardAnimations(holding, hero, this.x, this.y);			return AnimationStateUpdate(anim, false, false);			// this else is if its taunting 			}else{								bossHold = false;				//play some animation on sonic to get out				return AnimationStateUpdate("heroDodgedmyAttack", false, false);							}					}else{			return Status.S_FAILURE		}		}				public function BBossDiving(anim:String):String		{			if(bossDive){				// we need to track the hands for the most part see where they are//				hero.x = this.x;//				hero.y = this.y;			//HardAnimations(diving, hero, this.x, this.y);			//HardAnimations(bDiving, hero, this.x, this.y);			//trace("WE RUNNING DOG")			return AnimationStateUpdate(anim, false, false);		}else{			return Status.S_FAILURE		}		}				public function BBossSlapping(anim:String):String		{			if(bossSlapping){				// we need to track the hands for the most part see where they are				//trace("well we should be slapping");//				//trace(anim)			//HardAnimations(throwing, hero, this.x,this.y);			return AnimationStateUpdate(anim,false,false);			}else{				return Status.S_FAILURE			}		}						private function attackSwitch():void		{			switch(currAttack)			{				case 0:				{					bossHold = true;					break;				}				case 1:				{					bossThrow = true;					break;				}				case 2:				{					bossSlapping = true;					break;				}				case 3:				{					bossDive = true;					break;				}									default:				{					break;				}			}		}								override protected function attack():void		{			//then we have to set up special taunt parameters so it acts different, here it goes straight to checking the distance to see if its a dive or a grab of some sort thatll miss			if(!started)			{				bossDive = false;				bossHold = false;				bossSlapping = false;				bossThrow = false;				spaceCount = 0;
								//attack list looks like [[1000],[strike] ],[[4000][grab]] it just says the distance where it can do the attack				currAttack = randomRange(attackList.length-1);				currAttkDist = attackList[currAttack][0];				started = true;							}						if(hero.taunting)			{												if(distToSonic > currAttkDist)				{					attackSwitch();
					attacking = false					started = false;				}else{					bossDive = true;					attacking = false;					started = false				}							}else			{												if(distToSonic < currAttkDist+1000)				{					attackSwitch();										//attackList[3][1]					attacking = false;					started = false;									}else{// if(distToSonic > maxDist){					pursue("bBossPursuing");								}							}									// randomly pick what were gonna do but eventually i want random with percentages			// that means we then need to set the attack type and the distance required variables			// see how far we are, if we are too far away, we give pursuit,then do that attack, attack just hands off to other shit, doesnt actually do anything			// it can do pursue though it calls the function in here, and itll keep playing till its close enough or finished foot placing depending			//			//trace("attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!attacK!!!")		}						// you dont really need to worry to much about seperate limbs, if need be i can give direct access		// to the limbs, but more likely its just the same as the others just different pattern				//next step just find out what the next steps		// more than anything here im more concerned with moving and rotating the box		// for baby steps we can just place the box in the desired end location, then we'll make a starting point		//we'll do two for now both just place the end of the box at the attack position		// next just place two sprites and make them just follow 		// if attack position is shorter than its strike distance it does just an animation, dont worry about doing it mathmatically, because this way i could do more interesting movements		// next step is to create an interperter for the xml movements, should be easy, than make a class thatll let me grab and walk on it				// now were gonna layer things, those arm attacks are kind of like well default and handled by the group dynamix but were also gonna have him tackling and scrambling		// after the player is used to the thing				// at this point at the rough things should really start being alive, after this point it goes crazy			}}