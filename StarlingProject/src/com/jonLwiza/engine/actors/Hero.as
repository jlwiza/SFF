package com.jonLwiza.engine.actors{		import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.GeneralElements.Director;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainScene;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.baseConstructs.NPC;	import com.jonLwiza.engine.helperTypes.Status;	import com.jonLwiza.engine.helperTypes.Vector3;	import com.jonLwiza.engine.state.SonicBehavior;		import flash.events.TimerEvent;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.utils.Timer;		import starling.display.Image;	import starling.display.MovieClip;
		public class Hero extends GeneralActor	{				private var _spacebar:Boolean;		private var _sonicBehavior:SonicBehavior = new SonicBehavior();		private var _numberOfBaddies:int;		private var _closestConcern:Baddie = new Baddie();		private var _secondClosest:NPC = new NPC();		private var _rings:int = 0;		private var time_count:Timer;		private var _rolling:Boolean = false;		private var _standing:Boolean = false;		private var _hanging:Boolean = false;		private var _spinCharge:Boolean = false;		private var _charge:Number = 0;		private var jumpCount:Timer;		private var _heldOnTo:Array = new Array();		private var _walkSpeed:Number = 5;		private var _jogSpeed:Number = 15;		private var _runSpeed:Number = 40;		private var _sprintSpeed:Number = 65;		private var _notJumpedYet:Boolean;		private var _calls:int = 0;;		private var upAnim:String;		private var _passed:Boolean = false;		private var _tryAndGrab:Boolean = false;		private var _tryDodge:Boolean = false;		private var _localBaddies:Array = new Array();		private var _taunting:Boolean;		private var heroImage:Image;		private var _releasedDuringJump:Boolean;		// temp code blah blah you know the drill		public static var Anim:MovieClip;		private var tick:int;		public var coasting:Boolean;		public var badAttentionRnge:int;		public var isHit:Boolean = false;		public var customState:Boolean;		/** checkpoint just move it to the last place you want sonic to spawn from when he dies, I think the only i need to hook up is dying**/		public var checkPoint:Point = new Point(0,0);				public var spaceReleased:Boolean = true;				public function Hero()		{			super();			completeTweens = [//				["sonicJoggingTOsonicSkid"],["sonicWalkingTOsonicJogging"],["sonicJumpFallingTOsonicSkid"],["sonicPissedTOsonicPissed"],["sonicJumpFallingTOsonicWalking"],//				["sonicFallingTOsonicRunning"],["sonicFallingTOsonicFalling"],["sonicSkidTOsonicSkid"],["sonicJumpFallingTOsonicRunning"],["sonicJumpFallingTOsonicSprinting"],//				["sonicJumpFallingTOsonicJumpFalling"],["sonicIdleTOsonicWalking"],["sonicSkidTOsonicSkid"],["sonicRisingTOsonicRising"],["sonicRollingTOsonicRolling"],["thisTOthat"],//				["defaultTOsomething"],["somethingTOsomethingElse"],["sonicRisingTOsidewaysrunloop"],["sonicRisingTOsonicdying"],["sonicRisingTOsonicFalling"],["sonicRisingTOsonicHanging"],//				["sonicwaitingTOsonicCharging"],["sonicwaitingTOsonicDucking"],["sonicwaitingTOsonicDying"],["sonicwaitingTOsonicFalling"],["sonicwaitingTOsonicHanging"],["sonicwaitingTOsonicJumpRising"],//				["sonicwaitingTOsonicWalking"],["sonicJoggingTOsonicJogging"],["sonicJoggingTOsonicRunning"],["sonicRunningTOsonicRunning"],["sonicWalkingTOsonicWalking"],//				["sonicPissedTOsonicJumpRising"],["sonicIdleTOsonicJumpRising"],["sonicWalkingTOsonicwaiting"],["sonicSkidTOsonicWalking"],["sonicPissedTosonicPissed"]/*d*/];]						motorBTree = sonicBehavior;			sonicBehavior.actor = this;			scaleZ = 1		}								//SONIC'S STATES OF BEHAVIOR								override public function Damage():void		{			if(rings == 0 && !invincible && !dead){				dead = true;				//Director.nextScene()				time_count = new Timer(2*1000, 1);				time_count.addEventListener(TimerEvent.TIMER, restart);				time_count.start();			}else{				// hmm basically meaning i have to customize				// the damage sonic gets.. interesting				customState = true				rings = 0;				invincible = true;				time_count = new Timer(2*1000, 1);				time_count.addEventListener(TimerEvent.TIMER, clapOff);				time_count.start();			}					}				protected function restart(event:TimerEvent):void		{			time_count.removeEventListener(TimerEvent.TIMER, restart);			invincible = false;						Main.liveCamera.hero_mc.x = checkPoint.x			Main.liveCamera.hero_mc.y = checkPoint.y					}				protected function clapOff(event:TimerEvent):void		{			time_count.removeEventListener(TimerEvent.TIMER, clapOff);			invincible = false;		}		public function SonicCustomState(ani:Object):String		{			// this is really just a skeleton that i can look at to se how i override it			// i doubt ill access this directly like this			if(customState){								// maybe an array of deaths or custom i dunno				Animateto(ani);				return Status.S_RUNNING			}			return Status.S_FAILURE		}		public function SonicDying(ani:Object):String		{			if(dead){//				dead = true//				// maybe an array of deaths or custom i dunno				Animateto(ani);				return Status.S_RUNNING			}			return Status.S_FAILURE			//return AnimationStateUpdate(ani);		}				public function SonicDead(ani:Object):String		{			//if(dead)			return Status.S_FAILURE				//return AnimationStateUpdate(ani);		}				public function SonicRising(ani:Object):String		{			if(dead)			return Status.S_FAILURE						if(!hanging && !isGrounded && !isJumping && !triggerJumping && body.velocity.y > 0){				attacking = false;				Animateto(ani);								return Status.S_RUNNING// AnimationStateUpdate(ani,false,true);			}else{			return Status.S_FAILURE			}		}				public function SonicFalling(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(!hanging &&!isGrounded && !isJumping && body.velocity.y < 0)			{				attacking = false;			Animateto(ani);			//anim = "falling"			return Status.S_RUNNING//AnimationStateUpdate(ani,false,true);						}else{			return Status.S_FAILURE			}		}		// this was some dumb stuff Im gonna change or maybe not, it just keeps one foot on the ground for just a sec longer, weird but may have use		public function JumpCharge(ani:Object):String		{			if(dead)				return Status.S_FAILURE			// its actually a cool solution to this the animation that is sent, is actually just the one frame jump, its the transition that plays, when you let go it just cuts in			if(triggerJumping && isGrounded){				Animateto(ani)//AnimationStateUpdate(ani,false,true);				if(trani && calls < 1){					////trace(animStatus);					if(frame >= 2)					{						MainScene(currScene[0]).Jump(this);						calls++											}				}else if(!trani && calls < 1){//					//trace("no trani")					MainScene(currScene[0]).Jump(this);					calls++						Animateto(ani);						//AnimationStateUpdate(ani,true,true);				}				return  Status.S_FAILURE			}else{				return Status.S_FAILURE			}					}				public function SonicJumpRising(ani:Object):String		{			if(dead)				return Status.S_FAILURE								if(!hanging && !isGrounded && (isJumping || triggerJumping) && body.velocity.y > 0){				//attacking = true								// I need to put in a check incase trigger jumping doesnt go through to turn it off, else itll randomly do it								if(key.Y !=0)				{					// taunt is hizzere					if(closestConcern.distToSonic > 200 &&!closestConcern.attacking){						tryAndGrab = true						if (closestConcern is Baddie && closestConcern.distToSonic < badAttentionRnge) 
						{							currScene[0].reactToTaunt(Baddie(closestConcern))								// shouldnt need this but i changed stuff, so beware
//							Baddie(closestConcern).attackingState = true;//						Baddie(closestConcern).justAttacked = false;
						}											}else if(closestConcern.distToSonic <= 200 && closestConcern.attacking){						tryDodge = true;					}										}				if(!passed&& (tryAndGrab || tryDodge))				{					passed = true					if(tryAndGrab){						upAnim = "tryGrab";					}else if(tryDodge){						upAnim = "jumpTaunt";					}									}				if(!passed){					Animateto(ani);			return Status.S_RUNNING//AnimationStateUpdate(ani,false,true);				}else{					Animateto(upAnim)			return Status.S_RUNNING//AnimationStateUpdate(upAnim,false,true);				}			}else{			}return Status.S_FAILURE		}						public function SonicJumpFalling(ani:Object):String		{			if(dead)			return Status.S_FAILURE						if(!hanging && !isGrounded && isJumping && body.velocity.y < 0){				// i think all of this interaction junk should be done in gdym				//attacking = true;				if(key.Y != 0)				{					if(closestConcern.distToSonic > 200 &&!closestConcern.attacking){						tryAndGrab = true						if (closestConcern is Baddie && closestConcern.distToSonic < badAttentionRnge) 						{							currScene[0].reactToTaunt(Baddie(closestConcern))								// shouldnt need this but i changed stuff, so beware								//							Baddie(closestConcern).attackingState = true;								//						Baddie(closestConcern).justAttacked = false;						}											}else if(closestConcern.distToSonic <= 200 && closestConcern.attacking){						tryDodge = true;					}									}				if(!passed&& (tryAndGrab || tryDodge))				{					passed = true					if(tryAndGrab){						upAnim = "tryGrab";					}else if(tryDodge){						upAnim = "jumpTaunt";					}									}				if(!passed){					Animateto(ani);					return Status.S_RUNNING//AnimationStateUpdate(ani,false,true);				}else{					Animateto(ani)					return Status.S_RUNNING//AnimationStateUpdate(upAnim,false,true);				}			}else{			return Status.S_FAILURE			}					}				public function SonicHanging(ani:Object):String		{			if(key.Y !=-1){				return Status.S_FAILURE			}						if(hanging == true && heldOnTo.length > 0){			if(!isGrounded){					Animateto(ani)			return Status.S_RUNNING// AnimationStateUpdate(ani, false, true);			}else{				Animateto(ani)			return Status.S_FAILURE//AnimationStateUpdate(ani, false, true);			}			}else{							return Status.S_FAILURE			}		}				public function SonicGround():String		{			/**needs fixing **/			if(customState){						return Status.S_FAILURE;			}else{			return Status.S_RUNNING;			}		}				public function SonicSkid(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(skid && isGrounded && Math.abs(body.angularVel) >= walkSpeed ){			Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}else{								return Status.S_FAILURE;			}		}				public function SonicWalking(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(isGrounded && Math.abs(body.angularVel) >= walkSpeed && Math.abs(body.angularVel) < jogSpeed && key.Y <= 0 &&!skid && !triggerJumping)			{				////trace("states");				//just the basic one at first you just play one fram of the transfer than go to the next				//if(jumped && frame>= )//				if(scaleX != dir)//				scaleX = dir;				//this was just a very stupid bandaid//				if(key.X ==-(scaleX))//				return walkflip();				//if(animStatus = "sonicSkidTOsonicWalking")				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}else{				return Status.S_FAILURE			}			return Status.S_INVALId		}				private function walkflip():String		{			if(frame == 4)			scaleX = key.X			Animateto("walkTurnRoundAnimation")			return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			//return AnimationStateUpdate("walkTurnRoundAnimation", false, true);					}				private function flip():String		{			if(frame == 4)			scaleX = key.X			// if I could play this backwards and foward if I change mind would be nice but not neccessary						Animateto("turnRoundAnimation")			return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			//return AnimationStateUpdate("turnRoundAnimation", false, true);					}						public function SonicJogging(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(isGrounded && Math.abs(body.angularVel) >= jogSpeed && Math.abs(body.angularVel) < runSpeed && key.Y <= 0 &&!rolling &&!skid  && !triggerJumping)			{				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}			else{				return Status.S_FAILURE			}					}				public function SonicRunning(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(isGrounded && Math.abs(body.angularVel) >= runSpeed && Math.abs(body.angularVel) < sprintSpeed && key.Y <= 0 && !rolling&&!skid && !triggerJumping)			{				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}			else{				return Status.S_FAILURE			}		}				public function SonicSprinting(ani:Object):String		{			if(dead)			return Status.S_FAILURE						if(isGrounded && Math.abs(body.angularVel) >= sprintSpeed && !skid && !triggerJumping)			{				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}			else{				return Status.S_FAILURE			}		}				public function SonicRolling(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if((isGrounded && Math.abs(body.angularVel) >= 2 && Math.abs(body.angularVel) < sprintSpeed) && rolling  && !triggerJumping)			{								Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}			return Status.S_FAILURE;		}				public function JumpDash(ani:Object):String		{			// TODO Auto Generated method stub			return Status.S_FAILURE		}				public function SonicDucking(ani:Object):String		{			if(dead)			return Status.S_FAILURE						if(isGrounded && Math.abs(body.angularVel) < 2 && key.Y >0 && !spacebar){				//if(key.X>0)				//trace("ducking")				//somefunction that rolls in that direction dive maybe, it seems confusing so dont do it				stuck = true				 canJump = false;				 Animateto(ani)				 return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}								//return Status.S_RUNNING;			return Status.S_FAILURE;		}				public function SonicCharging(ani:Object):String		{			if(dead)			return Status.S_FAILURE								if(isGrounded && Math.abs(body.velocity.x) < 400 && key.Y >0 && spinCharge)			{				if(spacebar){					if(charge < 900)				charge += 90					// the direction when facing forward should be negative one but uhh yeah					body.angularVel = charge*5.5*dir*-1					triggerJumping = false				// this is good for testing but we have to change this to an event handler so its called more cleanly, it might be a good idea to do the same for when we touch the ground too, or not				//return AnimationStateUpdate("chargeSpin",false,true)				Animateto("chargeSpin")				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);				}else{					if(charge > .001)				charge -= .05;				else				charge = .001;				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);				}			}else{								return Status.S_FAILURE			}					}					public function SonicIdle(ani:Object):String		{			if(dead)			return Status.S_FAILURE			// we can probably use this as our turn around zone			if(isGrounded && Math.abs(body.angularVel) < 0.4 && key.Y <= 0 && !triggerJumping){//				if(key.X !=0)//				return flip();								Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, false);						}else{			return Status.S_FAILURE;		}		}				public function SonicWaiting(ani:Object):String		{			if(dead)				return Status.S_FAILURE								if(isGrounded && Math.abs(body.angularVel) < 2 && !triggerJumping && key.Y == 0){				//				if(key.X !=0 && key.X != scaleX)//				return flip();			//if(animStatus = "sonicSkidTOsonicWaiting")			if( Math.abs(body.angularVel) < 2){				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, false);			}else{				// i think i want like a slow walking in here//				Animateto("sonicWalking")				return Status.S_RUNNING//AnimationStateUpdate(ani, false, false);			//return AnimationStateUpdate("sonicWalking", false, false);			}			}else{			return Status.S_FAILURE;		}		}						public function SonicPissed(ani:Object):String		{			if(dead)				return Status.S_FAILURE			if(isGrounded && Math.abs(body.angularVel) < 0.4 && key.Y <= 0 && !triggerJumping){//				if(key.X !=0)//				return flip();				Animateto(ani)				return Status.S_RUNNING//AnimationStateUpdate(ani, false, true);			}else{			return Status.S_FAILURE;		}		}		// this is a bandaid as soon as i fix jump and make it connected to a event listener this will be obsolete and waste of code, since it will only jump on press not on down		public function waitJump():void		{						jumpCount = new Timer(2*100, 1);			jumpCount.addEventListener(TimerEvent.TIMER, jump_time);			jumpCount.start();		}				protected function jump_time(event:TimerEvent):void		{			canJump = true;			jumpCount.removeEventListener(TimerEvent.TIMER, jump_time);				}				public function get numberOfBaddies():int		{			return _numberOfBaddies;		}		public function set numberOfBaddies(value:int):void		{			_numberOfBaddies = value;		}		public function get secondClosest():NPC		{			return _secondClosest;		}		public function set secondClosest(value:NPC):void		{			_secondClosest = value;		}		public function get closestConcern():Baddie		{			return _closestConcern;		}		public function set closestConcern(value:Baddie):void		{			_closestConcern = value;		}		public function get sonicBehavior():SonicBehavior		{			return _sonicBehavior;		}		public function set sonicBehavior(value:SonicBehavior):void		{			_sonicBehavior = value;		}		public function get rings():int		{			return _rings;		}		public function set rings(value:int):void		{			_rings = value;		}		public function get standing():Boolean		{			return _standing;		}		public function set standing(value:Boolean):void		{			_standing = value;		}		public function get rolling():Boolean		{			return _rolling;		}		public function set rolling(value:Boolean):void		{			_rolling = value;		}		public function get hanging():Boolean		{			return _hanging;		}		public function set hanging(value:Boolean):void		{			_hanging = value;		}		public function get spacebar():Boolean		{			return _spacebar;		}		public function set spacebar(value:Boolean):void		{			_spacebar = value;		}		public function get spinCharge():Boolean		{			return _spinCharge;		}		public function set spinCharge(value:Boolean):void		{			_spinCharge = value;		}		public function get charge():Number		{			return _charge;		}		public function set charge(value:Number):void		{			_charge = value;		}		public function get heldOnTo():Array		{			return _heldOnTo;		}		public function set heldOnTo(value:Array):void		{			_heldOnTo = value;		}		public function get walkSpeed():Number		{			return _walkSpeed;		}		public function set walkSpeed(value:Number):void		{			_walkSpeed = value;		}		public function get jogSpeed():Number		{			return _jogSpeed;		}		public function set jogSpeed(value:Number):void		{			_jogSpeed = value;		}		public function get runSpeed():Number		{			return _runSpeed;		}		public function set runSpeed(value:Number):void		{			_runSpeed = value;		}		public function get sprintSpeed():Number		{			return _sprintSpeed;		}		public function set sprintSpeed(value:Number):void		{			_sprintSpeed = value;		}		public function get notJumpedYet():Boolean		{			return _notJumpedYet;		}		public function set notJumpedYet(value:Boolean):void		{			_notJumpedYet = value;		}		public function get calls():int		{			return _calls;		}		public function set calls(value:int):void		{			_calls = value;		}		public function get passed():Boolean		{			return _passed;		}		public function set passed(value:Boolean):void		{			_passed = value;		}				public function get tryDodge():Boolean		{			return _tryDodge;		}		public function set tryDodge(value:Boolean):void		{			_tryDodge = value;		}		public function get tryAndGrab():Boolean		{			return _tryAndGrab;		}		public function set tryAndGrab(value:Boolean):void		{			_tryAndGrab = value;		}		public function get localBaddies():Array
		{
			return _localBaddies;
		}		public function set localBaddies(value:Array):void
		{
			_localBaddies = value;
		}		public function get taunting():Boolean
		{
			return _taunting;
		}		public function set taunting(value:Boolean):void
		{
			_taunting = value;
		}		public function get releasedDuringJump():Boolean
		{
			return _releasedDuringJump;
		}		public function set releasedDuringJump(value:Boolean):void
		{
			_releasedDuringJump = value;
		}											}}