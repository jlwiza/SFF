package com.jonLwiza.engine.actors{	import com.greensock.TimelineMax;	import com.greensock.TweenLite;	import com.greensock.TweenMax;	import com.greensock.easing.Linear;	import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.GeneralElements.Path;	import com.jonLwiza.engine.IO.KeyPress;	import com.jonLwiza.engine.Scenes.EmptyScene;	import com.jonLwiza.engine.Scenes.FightScene;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainSceneMotor;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.baseConstructs.NPC;	import com.jonLwiza.engine.helperTypes.ActorPool;	import com.jonLwiza.engine.helperTypes.Status;	import com.jonLwiza.engine.helperTypes.Vector3;	import com.jonLwiza.engine.state.BadBehavior;	import com.jonLwiza.engine.state.SonicBehavior;	import com.jonLwiza.engine.state.sonicBehavior.Ground.Mobile.Running;		import flash.geom.Point;		import nape.geom.Vec2;		import starling.display.Image;	import starling.display.MovieClip;	import starling.filters.BlurFilter;	import starling.filters.FragmentFilter;
		public class Hornet extends Baddie	{		private var origin:Vector3 = new Vector3();		private var hornetBtree:BadBehavior = new BadBehavior();		private var stree:SonicBehavior = new SonicBehavior();		private var throwTimer:uint = 0;		private var _speed:Number = 0;		private var _angle:Number = 0;		private var _throwing:Boolean = false;		private var _started:Boolean =false;		private var an:Number;		private var throwAn:Number;		private var throwZAn:Number;		private var greaterThan:Boolean;		// this animation isnt time based its position based		private var testHAnim:Array = [[-200,-100],[-200,-200]];		private var lessthanSonic:Array = [[200,-100],[200,-200]];		//private var tl:TimelineMax;		private var loopBack:Boolean;		private var moveBack:Boolean;		private var homingPos:Vector3;		private var backtoHomeAfterAttack:uint = 0;		private var incrDist:Number = 45;		private var ticker:int = 0;		public var timeTocanAttack:int = 300;		private var _location:Point = new Point();		private var initialPoint:Vector3 =new Vector3();		private var endPoint:Vector3=new Vector3();		private var throwloc:Vector3=new Vector3();		private var throwGress:Number;		private var targetBaddie:NPC;		private var upt:Boolean;		public static var killcount:int;		private var brkout:Boolean = false;		private var _hrnetImage:String = "hornet";		public var autoTrack:Boolean = true;		private var isThrowable:Boolean = false;				private var redGlow:FragmentFilter		private var yelGlow:FragmentFilter		private var grnGlow:FragmentFilter								public function Hornet(im:String = "hornet")		{						hrnetImage = im;			super();			//definition			hornetBtree.actor = this;			comfortZone = 990;			baddieType = "hornet";			motorBTree = hornetBtree;			minDist = width; 			throwAn = 10*(Math.PI/180);			waitTime = 100;			timeTocanAttack = randomIntRange(300,100)			canAttack = false			completeTweens = [];			redGlow = BlurFilter.createGlow(0xff0000,1,0.5,1)			grnGlow = BlurFilter.createGlow(0x0000ff,1,0.5,1)			yelGlow = BlurFilter.createGlow(0xffff00,1,0.5,1)		}						//*********TEMPCODE**************		public function get hrnetImage():String
		{
			return _hrnetImage;
		}		public function set hrnetImage(value:String):void
		{
			_hrnetImage = value;
		}//		override protected function createArtAsset():void//		{//			//			var imge:Image = new Image(Assets.getTexture(hrnetImage));//			imge.x = 0//			imge.y = 0//			addChild(imge);//			//			//		}				override public function Destroy():void		{			// play some dead animation, let sonic or gdyn pass you what the animation will be wait till completed then remove			//handle the bounce and everything 			//hero.gv.Y = -45;			// I just wanted to cancel out the blocking thing because its very changeable when blocking works and is effective, so yeah			if(!blocking || true ){			if(!dead){//				hero.body.velocity.x = 0;//				hero.body.velocity.y = 0;//				hero.body.applyImpulse(Vec2.get(-50,-1500));						// we implement a jumo to other points after this it'll also help control thing like hangtime						//hero.moveVector.X = 25*hero.key.X;			//var blast:MovieClip =  new MovieClip(Assets.getAtlas(atlas).getTextures("hornetExplosion"), 24);			// i dont think its necessary but doesnt hurt				body.position.x = 0;				body.position.y = 0;			killcount++			MainSceneMotor.space.bodies.remove(body)			removeFromParent();				dead = true;			alpha = 0;			}			//temp						}else{							//	hero.body.applyImpulse(Vec2.get(-20,-50));			}		}		// when this is optimized only the closest one should be updating to see his distance to sonic, the other ones behaviors are directed by sonic but this is a lil complicate so baby steps		override protected function wait():void		{			// might  consider making a moveback state			//UpdateDistToSonic()			straightto(currScene[0].hornetIdle)			if(!moveBack){			origin.X = hero.X;			origin.Y = hero.Y - 90;			}						if(justAttacked){				shape.scale(2,2)				started = false				timeTocanAttack = randomIntRange(100,50);			justAttacked = false;			}				if(timeTocanAttack > 0)				timeTocanAttack--;				else				attackingState = true;											// this is the code you get rid of if group dynamics is on, and im leaning towards getting it working again, but only as polish as it adds			// variety in the ways the fight can go//			if(canAttack){//			attackingState = true//			timeTocanAttack = 25//				}									// I need to move this to group dynamix too itll help also cuz then i can more cleverly use hitTest, so two of em dont get hanged from						// umm i used sonicCollision on this but its not going to work in some circumstances, all it does is check the physics engine shite				if( hero.key.Y == -1 && !hero.hanging && hitTestObject(hero))			{								isHeld = true;				hero.hanging = true;				KeyPress.spacebar = false;				hero.spacebar = false			}else{							}			// this is the special animation thats not time based that is position based, and makes it go step by step// note we could layer in animation on top of this if we wanted we would just have to make a local home position or whatever//			if(moveBack){//				// that hanim pos is terrible naming itll get confusing real quick.. oh well//			// alright to bypass this multiple animation on different things and layers of animation problem there are two solutions, create a new incrementor for every different animation, or a new class, a new class has more overhead and will needed to create a new instance everytime so i think im just gonna do it a straight up way like sososososososossososososososososooooooooo//			//			//remember use function for expansion, this is very rough and dumb	//			//				if(greaterThan){//				easeIn(this,testHAnim[backtoHomeAfterAttack][0]+ origin.X,testHAnim[backtoHomeAfterAttack][1] + origin.Y, 1/8)//				if(DistToPointXY(testHAnim[backtoHomeAfterAttack][0]+ origin.X,testHAnim[backtoHomeAfterAttack][1]+ origin.Y) < incrDist)//					backtoHomeAfterAttack++;//				}else{//					easeIn(this,lessthanSonic[backtoHomeAfterAttack][0]+ origin.X,lessthanSonic[backtoHomeAfterAttack][1] + origin.Y, 1/8)//					if(DistToPointXY(lessthanSonic[backtoHomeAfterAttack][0]+ origin.X,lessthanSonic[backtoHomeAfterAttack][1]+ origin.Y) < incrDist)//						backtoHomeAfterAttack++;//				}////			//					//this can be expanded to include any types of movement replace testHanim 1 and 2 with blank variables determine what kind of return you want from the conception of attack so maintaining whatever flow is easy ////			        May just change it all into a function in hard animation class and place the name into the thingy, yeah thats better////			////			//				////trace(DistToPointXY(testHAnim[backtoHomeAfterAttack][0]+ origin.X,testHAnim[backtoHomeAfterAttack][1]+ origin.Y));//					
//				//				//				if (backtoHomeAfterAttack == testHAnim.length) 
//				{//					moveBack = false;
//					backtoHomeAfterAttack = 0; 
//				}//			//				
//			}											//easeIn(this,homingPos);					}						override protected function hold():void		{			canAttack = false			ticker = 0			attackingState = false;						if(hero.key.Y !=-1 || hero.spacebar){				hero.hanging = false;				isHeld = false;				angle = 0;				//				if (throwTimer >= 20) //				{				 isThrowable = true				//}				// this seems inconsistant in logic because it should be in mainscenemotor.. but I was never too consistant in top level programming, since it should be flexible				// also how an baddie reacts when I press spacebar while holding them is very changeable				// it has to listen for an onspacebar press kinda deal				if (hero.spacebar && isThrowable) 				{					thrown = true;										initialPoint.X = X					initialPoint.Y = Y					initialPoint.Z = Z					initialPoint.D = 0										endPoint.X = hero.closestConcern.X					endPoint.Y = hero.closestConcern.Y					endPoint.Z = hero.closestConcern.Z					endPoint.D = hero.closestConcern.distToSonic																throwGress = 0					targetBaddie = hero.closestConcern					body.cbTypes.add(MainSceneMotor.thrownBaddie)					targetBaddie.body.cbTypes.add(MainSceneMotor.targetBaddie)//					shape.sensorEnabled = false;//					targetBaddie.shape.sensorEnabled = false;					hero.hanging = false;					isHeld = false;				}			}else{//			hero.x = x;//			hero.y = y;											if(!throwing || !hero.spacebar){//			hero.body.position.x  +=1 //			savedposition of hero.x as soon as it got into it //			hero.body.position.y -=1				if(autoTrack){			location.x = focus.X+Math.cos(angle)*(dx);			location.y = focus.Y+Math.cos(angle*2)*(dy);			Main.liveCamera.hero_mc.body.velocity.setxy(0,0)			Main.liveCamera.hero_mc.body.position.y = location.y						Main.liveCamera.hero_mc.body.position.x = location.x						body.position.x = location.x			body.position.y = location.y				}else{					// we'll  have to remove location.x					location.x = focus.X					location.y = focus.Y					Main.liveCamera.hero_mc.body.velocity.setxy(0,0)					Main.liveCamera.hero_mc.body.position.y = location.y								Main.liveCamera.hero_mc.body.position.x = location.x											body.position.x = location.x					body.position.y = location.y				}//			hero.X = x;//			hero.Y = y;			speed = .05			//			x =hero.X//			y =hero.Y			angle += speed;			}			}			//actor.gv.Y = Math.sin(angle)*speed;		}				override public function throwBaddie():void		{												if(!throwing){				hero.spacebar = false;				//FightScene(currScene).ThrowFlyingBadGuy(hero, this);				hero.gv.Y = 45*hero.key.Y;				// we implement a jumo to other points after this it'll also help control thing like hangtime				hero.moveVector.X = 25*hero.key.X;				// if we have problems we need to check closest concerns				var dy:Number = hero.closestConcern.Y- Y;				var dx:Number = hero.closestConcern.X - X;				var dz:Number = hero.closestConcern.Z - Z;				throwAn =Math.atan2(dy, dx);				throwZAn = Math.atan2(dz, dx);			throwing = true;			isThrowable = false;//			Main.liveCamera.npcs.sortOn("distToSonic",  Array.NUMERIC);//			if(Main.liveCamera.npcs[0] == this){//				hero.closestConcern = Main.liveCamera.npcs[1]//			}else{//				hero.closestConcern = Main.liveCamera.npcs[0]//			}						}else{				throwGress+= 6				//throwloc = Path.SnapToPath(throwGress,initialPoint, endPoint)					// I leave this here cuz i dont actually need the bodies anymore at this point they are both dead//				body.position.x= throwloc.X//				body.position.y= throwloc.Y//				Z= throwloc.Z					//				body.position.x= endPoint.X//				body.position.y= endPoint.Y//				Z= endPoint.Z//				tl = new TimelineMax()								var time:Number = 0.2				//add a tween//				tl.insert(TweenLite.to(this.body.position, time, {x:targetBaddie.body.position.x,  ease:Linear.easeNone}));//				tl.insert(TweenLite.to(this.body.position, time, {y:targetBaddie.body.position.y}));//				tl.insert(TweenLite.to(this, time, {Z:targetBaddie.Z}));				 				if(Math.abs(body.position.x - targetBaddie.body.position.x)<5)				{						//Destroy()						//trace("this is the baddie being destroyed: ", this.X)						targetBaddie.life = 0; // Destroy()						targetBaddie.Destroy()						Destroy()						upt = true;										}			}				}				override protected function attack():void		{//			//trace("attacking")										if(!started){				if(body.position.x > hero.body.position.x)					greaterThan = true;				else					greaterThan = false;				justAttacked = true				an = angleBtwnPts(new Vector3(body.position.x,body.position.y), origin);				started = true;				// if I so choose it may be a good idea to prepare my camera, 								//so i can give it its end positions herr				if (true) 
				{//					tl = new TimelineMax()//					//var finalx = this.body.position.y//					//add a tween//					tl.insert(TweenLite.to(this.body.position, 0.5, {x:hero.body.position.x,  ease:Linear.easeNone}));//					tl.insert(TweenLite.to(this.body.position, 0.5, {y:hero.body.position.y + 20}));//					//					//add another tween at the end of the timeline (makes sequencing easy)//					tl.appendMultiple([TweenLite.to(this.body.position, 0.5, {x:hero.body.position.x+800, ease:Linear.easeNone}),//						TweenLite.to(this.body.position, 0.5, {y:hero.body.position.y+600})					////					testHAnim = [[-200,-100],[-200,-200],[x,y]];//					lessthanSonic = [[200,-100],[200,-200], [x,y]];
				}				shape.scale(.5,.5)			}						if(!moveBack){				if(sonicCollision){				hero.Damage()				}			}						 if(true){				 attackingState = false			 }			if(greaterThan){				if(body.position.x < hero.body.position.x){				moveBack =true;				attacking  = false;				//started = false;				ticker = 0;								}			}else{								if(body.position.x> hero.body.position.x){				moveBack = true;				//started = false;				//easeIn(this,testHAnim[backtoHomeAfterAttack][0],testHAnim[backtoHomeAfterAttack][1])				attacking = false;				}			}											}								//		override public function set X(value:Number):void//		{//			trace//			X = value//		}		override public function Dead():String
		{			// i can actually just check if theyre life equals zero and remove them from the object pool, but for now I dont mind this			if(life == 0){				Destroy();			return Status.S_RUNNING;
			}else{
			return Status.S_FAILURE;
			}
		}		public function get angle():Number
		{
			return _angle;
		}		public function set angle(value:Number):void
		{
			_angle = value;
		}		public function get speed():Number
		{
			return _speed;
		}		public function set speed(value:Number):void
		{
			_speed = value;
		}		public function get throwing():Boolean
		{
			return _throwing;
		}		public function set throwing(value:Boolean):void
		{
			_throwing = value;
		}		public function get started():Boolean
		{
			return _started;
		}		public function set started(value:Boolean):void
		{
			_started = value;
		}		public function get location():Point
		{
			return _location;
		}		/**change the location while being held **/		public function set location(value:Point):void
		{
			_location = value;
		}					}}