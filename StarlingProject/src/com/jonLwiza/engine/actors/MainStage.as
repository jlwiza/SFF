package com.jonLwiza.engine.actors{	import com.jonLwiza.engine.Main;	import com.jonLwiza.engine.GeneralElements.Director;	import com.jonLwiza.engine.GeneralElements.Ground;	import com.jonLwiza.engine.GeneralElements.GroupDynamix;	import com.jonLwiza.engine.Scenes.BugEntry;	import com.jonLwiza.engine.Scenes.FightScene;	import com.jonLwiza.engine.Scenes.HornetBossBattle;	import com.jonLwiza.engine.Scenes.HornetBossScene;	import com.jonLwiza.engine.Scenes.HornetNest;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainScene;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainSceneMotor;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralActor;	import com.jonLwiza.engine.baseConstructs.GeneralMotor;	import com.jonLwiza.engine.baseConstructs.SceneHandler;	import com.jonLwiza.engine.baseConstructs.Target;	import com.jonLwiza.engine.helperTypes.QuickRect;	import com.jonLwiza.engine.helperTypes.TMXParser;	import com.jonLwiza.engine.helperTypes.Vector3;		import flash.geom.Point;	import flash.geom.Vector3D;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		import away3d.containers.ObjectContainer3D;		import dragonBones.Armature;	import dragonBones.Bone;		import nape.phys.Body;	import nape.phys.BodyType;	import nape.shape.Polygon;	import nape.shape.Shape;		import starling.core.Starling;	import starling.display.DisplayObject;	import starling.display.Image;	import starling.display.MovieClip;	import starling.display.Sprite;	import starling.events.Event;	import starling.textures.Texture;
	import com.jonLwiza.engine.baseConstructs.NSprite;
		public class MainStage extends GeneralMotor	{		private var someVal:Number;		public var pos:Vector3= new Vector3();		private var spd:int;		private var angle:int;		private var _pwidth:Number = 848;		private var _pheight:Number = 480;		//remembre to change this to private with getters and setters		//public var rotationSet:SetPiece;		public static var X:Number;		public static var Y:Number;		public static var Z:Number;		private var foregroundSpeed:Number;		private var backgroundSpeed:Number;		private var farBackSpeed:Number;		private var farthestBackSpeed:Number;		private var _vpX:Number = 424;		private var _vpY:Number = 200;		private var _fl:Number = 250;		private var tmx:TMXParser = new TMXParser(); 		private var _hero_mc:Hero = new Hero();		private var _bigBaddie:BaddieBoss = new BaddieBoss();		public var mainScene_mc:MainScene = new MainScene();				public var ctScene_mc:Scenary = new Scenary(null);		public var speed:Vector3 = new Vector3()		private var column:int;		private var row:int;		private var visRows:uint = 3;		private var iterNum:int = 12;		private var dij:Image;		private var _targetingRecticle:AnimatedScenary;		private var firstMap:Vector3 =new Vector3();		private var fMapRows:uint  = 79;		private var textureImage:String = "interp_";		private var gid:Array = new Array();		// please remember to remove I know I wont		private var loaded:Boolean = false;		private var que:Array = [[1,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]];		private var bgImages:Vector.<Image> = new Vector.<Image>(); 		private var relMapCam:Vector3 = new Vector3();		private var sqPixel:uint  = 256;		private var lastQue:Array = [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]];		private var board:Vector.<Image> = new Vector.<Image>()		private var live:Vector.<Boolean> = new Vector.<Boolean>();		private static var _baddies:Array = new Array();//Vector.<Hornet> = new Vector.<Hornet>(); 		private static var _scnes:Vector.<SceneHandler> = new Vector.<SceneHandler>();		//private var assets:Assets = new Assets();		private var waitList:Array = [[1,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]		private var gThrough:Boolean = false;		private var knum:int= 0;		private var _map:Map = new Map();		private var _mapTest:Sprite = new Sprite();		private var _sonicMoved:Boolean = false;		private var camAdjust:Boolean;			private var _hornetBossScene:HornetBossScene = new HornetBossScene();		private var _fightScene_mc:FightScene = new FightScene();		private var _spawn1:MovieClip		private var _spawn2:MovieClip		private var _hrnets2:Array= new Array();		private var _hrnets3:Array= new Array();		private var _hrnets4:Array= new Array();		private var _hrnets5:Array= new Array();		private var _hrnets6:Array= new Array();		public var npcs:Array;		public var gDym:GroupDynamix = new GroupDynamix();		private var _baddiSpots:Array = new Array();		//private var 		private var _baddiRects:Array = new Array();		private var updatetest:Boolean;		private var _armatureClip:Sprite//		private var _armature:Armature//		private var _head:Bone;//		private var _armR:Bone; //		private var _armL:Bone;//		private var _handR:Bone;		private static var _rings:Array = new Array();		private var _collisionVolumes:Array = new Array();				private var _collisionTarget:Target;		private static var pHero:Hero;		private static var _scenary:Array = new Array();		private var _test:AnimatedScenary;		public static var lookAtTarget:ObjectContainer3D = new ObjectContainer3D();		public static var distance:Number;		public var dt:Number = 0;		public function MainStage()		{			//the main scene subclasses this			super();						this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			//dij = new Image(Assets.getTexture("Control"));			// umm this is weird but im gonna put you it here			Scenes;					}										//		public function get handR():Bone//		{//			return _handR;//		}//		//		public function set handR(value:Bone):void//		{//			_handR = value;//		}				public static function PlaceSonic(x:Number,y:Number,z:Number):void		{			if(pHero){				pHero.X = x;				pHero.Y = y;				pHero.Z = x;			}else{				throw new Error("hero Not yet defined, or somethings fucking up");			}		}				public function addGroundPoints(points:Array):void		{					}						public function addGroundPoint(points:Array, x:Number,y:Number,z:Number):void		{					}						public function addNewScene(x:Number,y:Number,z:Number, w:Number,h:Number, depth:Number = 5, scneName:String = null):*		{			var scne:* 			if(scneName != null && scneName != "Scenes")			{				// must change this			var clss:Class = getDefinitionByName("com.jonLwiza.engine.Scenes."+scneName) as Class;						scne = new clss()			}else{			scne = new Scenes();			}			scnes.push(scne)			Main.liveCamera.addChild(scne);			scne.X = x;			scne.Y = y;			scne.Z = z;			scne.width = w;			scne.depth = depth				return scne		}								public function UpdateZDepth(a:Object, ignoreVP:Boolean = true):void		{			// this assumes that the actor is inside and its parent is camera its just a note for everything to work its parent has to be camera I can put a check on general motor to check on added to stage			//var scale:Number = fl/(fl +(a.Z-cameraZ));			// the way away3dview is set up is very dumb but things need to change so for now.. rock on						var r:Vector3D = LevelEditor.away3dView.project(new Vector3D(a.X,a.Y,a.Z))			var y:Vector3D = LevelEditor.away3dView.project(new Vector3D(a.X+LevelEditor.perpRtYSin*90,a.Y,a.Z+LevelEditor.perpRtYCos*90))			var scale:Number = a.scaleZ*(y.x -r.x)/180 //fl/(fl +r.z);			//trace(Math.cos((LevelEditor.awyCam.rotationY+90)*Math.PI/180))			// so its on button down or whatevs thats one however far out that									if(r.z >= 90){				a.fkalpha = a.oldAlpha								a.scaleX = scale*a.scaleZ;				a.scaleY = scale*a.scaleZ;								if(a is NSprite && r.z >= 4000){					a.scaleX = .1					a.scaleY = .1									}												//trace(PerspectiveLens(LevelEditor.away3dView.camera.lens).focalLength, " is my focal length")				var fl:Number =  1.5696855771174902				var z:Number = r.z								//unproject looks something like a.X = a.X = (a.x*r.z)/fl									a.x = fl*a.X/r.z								//a.x =  r.x //- (a.width*a.scaleX)/2				a.y =  200 + fl*1/r.z 				a.z =  r.z				//			if(ignoreVP){				//			a.x = vpX + (a.X - vpX)*scale;				//			a.y = vpY + (a.Y - vpY)*scale;				//			}			}else{				a.fkalpha = 0				a.scaleX = .0001				a.scaleX = .0001				//				a.x = -99				//				a.y = -999				//								}		}		/** 		 * if you're on the path z refers to the offset on the path if its default its best to just set the z to 0		 */		public function addNewBaddie(x:Number, y:Number, z:Number, animations:Array, badClass:String = "Hornet",onPath:Boolean = true, dIndex:int = -1):Baddie		{																	var badNick:Class = getDefinitionByName("com.jonLwiza.engine.actors."+badClass) as Class;						var hrnt:Hornet = new badNick(badClass);						_baddies.push(hrnt)			npcs.push(hrnt)			addChild(hrnt);						hrnt.X = x;			hrnt.Y = y;			hrnt.Z = z;			hrnt.localZ = z			hrnt.isOnPath = onPath			hrnt.drctrIndx = dIndex			// this is expensive...			// oh well i plan on killing it anyway				var box:Body = new Body(BodyType.KINEMATIC);				var poly:Shape = new Polygon(Polygon.box(90, 80))				box.shapes.add(poly);				box.position.setxy(x,y)//6282.914564796065, 1279.250048828125);				box.space = MainSceneMotor.space;//				box.cbTypes.add(MainSceneMotor.thrownBaddie)				box.cbTypes.add(MainSceneMotor.hrnetBaddie)				box.userData.graphic = hrnt				hrnt.body = box //.position.setxy(body.x,body.y)				hrnt.shape = poly				poly.sensorEnabled = true				hrnt.currScene[0] = Director.sceneList[Director.playingScene]					return hrnt					}		public function addNewRing(x:Number, y:Number, z:Number, animations:Array = null,dIndex:int = 1):void		{			var ring:Rings = new Rings();			_rings.push(ring)			addChildAt(ring,0);			ring.X = x			ring.Y = y			ring.Z = z			ring.drctrIndx = dIndex			// onClick						//			for (var i:int = 0; i < stage_mc.npcs.length; i++) 			//			{			//				if(!stage_mc.npcs[i].dead){			//								//								//								//								//								//								//					if(110 > stage_mc.npcs[i].distToSonic){			//									//						stage_mc.hero_mc.closestConcern = stage_mc.npcs[i];			//									//					}			//				}			//			}		}				public function addNewPoint(x:Number, y:Number, z:Number, texture:Texture):void		{			var img:Image = new Image(texture)			var point:Scenary = new Scenary(img);			scenary.push(point)			addChild(point);						point.x = x			point.y = y			point.Z = z								}				/**not sure if it fully works scenary name is a unique identifier so i can get reference to it during the que**/		public function SmartLoadScenary(x:Number, y:Number, z:Number, imageName:String = "",name:String="",frames:uint= 1, front:Boolean = false, scale:Number = 1, dIndex = -1):Scenary		{		// I'm putting loadQue different then the other quelist so that loadque is easy and all it does is load things and then inform another function that its done loading		if(frames ==1){		Assets.LoadQue.push(imageName);		var scnry:Scenary = new Scenary();		scnry.name = name		_scenary.push(scnry)		Assets.ScenaryQue.push({imageName:imageName,x:x,y:y,z:z,scenaryName:name,frames:frames,scenary:scnry, dIndex:dIndex})		return scnry		}else if(frames > 1){			for (var i:int = 0; i < frames; i++) 			{				Assets.LoadQue.push(Assets.frameName(imageName,i+1))			}			var animScnry:AnimatedScenary = new AnimatedScenary();			animScnry.name = name			_scenary.push(animScnry)			Assets.ScenaryQue.push({imageName:imageName,x:x,y:y,z:z,scenaryName:name,frames:frames,scenary:animScnry, dIndex:dIndex})			return animScnry		}				 return null		}				public  function addNewScenary(x:Number, y:Number, z:Number, img:Image, name:String = "",scnry:Scenary = null, front:Boolean = false, scale:Number = 1, dIndex:int = -1):Scenary		{						scnry = new Scenary(img);						_scenary.push(scnry)			if(front)			addChild(scnry);			else			addChildAt(scnry, 0)			scnry.X = x;			scnry.Y = y;			scnry.Z = z;			scnry.name = name			scnry.frms = 1;			scnry.drctrIndx = dIndex			scnry.scaleZ =scale			return scnry;		}				// we should eventually change this to override get child by name but well eventually itd be nice		/** okay this is a risky dangerous function that i only use in one place		 it should be fine but it also deletes any other scenaries		 if there are more than one of the same name because the names should be unique **/		public function getScenaryByName(name:String, andClean:Boolean = false):Array		{			var kids:Array = [];			var numChildren:int = _scenary.length;			for (var i:int=0; i<numChildren; ++i){				if (_scenary[i].name == name){ kids.push( _scenary[i]);					if(andClean){				if(kids.length > 1){					scenary[i] = null				scenary.splice(i, 1);				}				}				}			}			return kids;		}				public  function addNewAnimatedScenary(x:Number, y:Number, z:Number, texts:Vector.<Texture>, name:String = "",scnry:AnimatedScenary = null,front:Boolean = false, scale:Number = 1,dIndex = -1):AnimatedScenary		{						var scene:String = getQualifiedClassName(Director.sceneList[Director.playingScene]);			var dname:String = scene.slice(scene.search("::")+2)			if(name == ""){			var fname:String = dname+"_image"+_scenary.length			}else{			fname = name; 			}				// I'd really like to get rid of this but i need to use the image one because thats the one i can edit, and changing that would be time consuming			if(false){//texts.length == 1|| !texts){				if(!texts){				 addNewScenary(x,y,z,new Image(Assets.getTexture("Blank")),fname)				}else				 addNewScenary(x,y,z,new Image(texts[0]),fname)					 return null;			}else{						scnry= new AnimatedScenary();			scnry.texts = texts			_scenary.push(scnry)			if(front){			addChild(scnry)			}else			addChildAt(scnry, 0)			scnry.X = x;			scnry.Y = y;			scnry.Z = z;			scnry.name = name			scnry.frms = scnry.movie.numFrames			scnry.drctrIndx = dIndex			scnry.scaleZ =scale				return scnry			}		}				/**this is obviously costly and a waste of time during start		 *up but its fine while testing so yeah make sure to add a pop up to remember to render these frames out or something		 * because even though ill have the bigguns fixed there it wont be fixed in the texture sheet that has to be done manually		 * but i may be able to help by at least sticking to naming conventions anyway i think most of them are still there in there		 * original form */		public static function editAnimation(todo:Object):void		{			//			if(removeFrames.length > 0)			//			todo.movie 		}		public function setMap():void		{			 			var j:int = 0;			baddies = []			var badPts:Array = ResourceManager.crntScneResources[ResourceManager.Hornets]			for (j = 0; j < badPts.length; j++) 			{ 			//	hrnets.push(new Hornet())				addChild(baddies[j]);				baddies[j].X = badPts[j][0];				baddies[j].Y = badPts[j][1];			}			badPts = ResourceManager.crntScneResources[ResourceManager.Rings]			rings = [];			for (j = 0; j < badPts.length; j++) 			{				rings.push(new Rings())				addChild(rings[j]);				rings[j].X = badPts[j][0];				rings[j].Y = badPts[j][1];			}			badPts = ResourceManager.crntScneResources[ResourceManager.Scenary]			scenary = [];			for (j = 0; j < badPts.length; j++) 			{				scenary.push(new Scenary(new Image(Assets[badPts[j][3]])))				addChild(rings[j]);				scenary[j].X = badPts[j][0];				scenary[j].Y = badPts[j][1];			}			Ground.ptsArray = ResourceManager.crntScneResources[ResourceManager.GroundPaths] 							badPts = ResourceManager.crntScneResources[ResourceManager.Scene]			scnes = null;			for (j = 0; j < badPts.length; j++) 			{				scnes.push(badPts[j][0])				addChild(scnes[j]);				scnes[j].X = badPts[j][1];				scnes[j].Y = badPts[j][2];				scnes[j].Z = badPts[j][3];				// width and height also needed			}			// ok scenes work similar to cutd		}		private function onAddedToStage(event:Event):void		{			this.removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);						for (var i:int = 0; i < iterNum; i++) 			{				lastQue.push([0,0,0]);				que.push([0,0,0])				waitList.push([0,0,0])				live.push(false);				bgImages.push(new Image(Assets.getTexture("interp_79")));				}						// All the Baddie types should go HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!			Cars;									pHero = hero_mc			addChild(map);			addChild(hero_mc);			hero_mc.alpha = 1			addChild(mapTest);			mapTest.alpha = 0.5						var sonicPts:Array = tmx.objectSet("Hero");			var bigBadPts:Array = tmx.objectSet("Baddie","BaddieBoss");			var spawn1Pt:Array = tmx.objectSet("spawn1")			var spawn2Pt:Array = tmx.objectSet("spawn2")			var badPts:Array = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors");			var mapPts:Array = tmx.objectSet("Map");			var j:int = 0;//			for (j = 0; j < badPts.length; j++) //			{ //				hrnets.push(new Hornet())//				addChild(hrnets[j]);//				hrnets[j].x = badPts[j][0];//				hrnets[j].y = badPts[j][1];//			}			badPts = tmx.objectSet("NPC","Ring",TMXParser.OBJECTLAYERS,"rings");			for (j = 0; j < badPts.length; j++) 			{				rings.push(new Rings())				addChild(rings[j]);				rings[j].X = badPts[j][0];				rings[j].Y = badPts[j][1];			}			badPts = tmx.objectSet("NPC","Ring",TMXParser.OBJECTLAYERS,"znear");			for (j = 0; j < badPts.length; j++) 			{				rings.push(new Rings())				addChild(rings[j]);				rings[j].X = badPts[j][0];				rings[j].Y = badPts[j][1];				rings[j].Z = -150			}			badPts = tmx.objectSet("NPC","Ring",TMXParser.OBJECTLAYERS,"zfar");			for (j = 0; j < badPts.length; j++) 			{				rings.push(new Rings())				addChild(rings[j]);				rings[j].X = badPts[j][0];				rings[j].Y = badPts[j][1];				rings[j].Z = 150			}			badPts = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors2");//			for (j = 0; j < badPts.length; j++) //			{//				hrnets2.push(new Hornet())//				addChild(hrnets2[j]);//				hrnets2[j].x = badPts[j][0];//				hrnets2[j].y =  badPts[j][1];//			}			// i may end up pushing these in by locations			badPts = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors3");//			for (j = 0; j < badPts.length; j++) //			{//				hrnets3.push(new Hornet())//				addChild(hrnets3[j]);//				hrnets3[j].x = badPts[j][0];//				hrnets3[j].y = badPts[j][1];//			}			badPts = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors4");//			for (j = 0; j < badPts.length; j++) //			{//				hrnets4.push(new Hornet())//				addChild(hrnets4[j]);//				hrnets4[j].x = badPts[j][0];//				hrnets4[j].y = badPts[j][1];//			}			badPts = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors5");//			for (j = 0; j < badPts.length; j++) //			{//				hrnets5.push(new Hornet())//				addChild(hrnets5[j]);//				hrnets5[j].x = badPts[j][0];//				hrnets5[j].y = badPts[j][1];//			}			badPts = tmx.objectSet("Baddie","Hornet",TMXParser.OBJECTLAYERS,"actors6");//			for (j = 0; j < badPts.length; j++) //			{//				hrnets6.push(new Hornet())//				addChild(hrnets6[j]);//				hrnets6[j].x = badPts[j][0];//				hrnets6[j].y = badPts[j][1];//			}									////trace("jhh  ", hrnets)			var cut:Array = tmx.objectSet("Cut"); 			var bugEntrypt:Array = tmx.objectSet("Trigger","BugEntry");			var hornetNestpt:Array = tmx.objectSet("Trigger","HornetNest");			var hornetBossBattlept:Array = tmx.objectSet("Trigger","HornetBossBattle");			var hornetBossScenept:Array = tmx.objectSet("Trigger","HornetBossScene");												baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets")[0]));						baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets2")[0]));			baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets3")[0]));			baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets4")[0]));			baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets5")[0]));			baddiRects.push(new QuickRect(tmx.objectSet("Trigger","hrnets6")[0]));			//			//trace(baddiRects[5].x)//			//trace("map kj pts",mapPts[0][0]," ", mapPts[0][1]);//			map.x =mapPts[0][0];//			map.y =mapPts[0][1];//			mapTest.x = mapPts[0][0];//			mapTest.y = mapPts[0][1];			//			addChild(bugEntry)//			bugEntry.x = bugEntrypt[0][0];//			bugEntry.y = bugEntrypt[0][1];//			bugEntry.width = bugEntrypt[0][2];//			bugEntry.height = bugEntrypt[0][3];			//			addChild(hornetNest);//			hornetNest.x = hornetNestpt[0][0];//			hornetNest.y = hornetNestpt[0][1];//			hornetNest.width = hornetNestpt[0][2];//			hornetNest.height = hornetNestpt[0][3];			//			//trace(hornetNest.width, "this stuff is endless idnet it",hornetNest.height);			//			addChild(hornetBossBattle);//			hornetBossBattle.x = hornetBossBattlept[0][0];//			hornetBossBattle.y = hornetBossBattlept[0][1];//			hornetBossBattle.width = hornetBossBattlept[0][2];//			hornetBossBattle.height = hornetBossBattlept[0][3];			//			addChild(hornetBossScene);//			hornetBossScene.x = hornetBossScenept[0][0];//			hornetBossScene.y = hornetBossScenept[0][1];//			hornetBossScene.width = hornetBossScenept[0][2];//			hornetBossScene.height = hornetBossScenept[0][3];						//scnes.push(SceneHandler(hornetNest),SceneHandler(hornetBossScene), SceneHandler(bugEntry),SceneHandler(hornetBossBattle));			var tutorialBarrier:Array = tmx.objectSet("Trigger","TutorialBarrier");			collisionTarget = new Target(); //			addChild(collisionTarget);//			collisionTarget.x = tutorialBarrier[0][0];//			collisionTarget.y = tutorialBarrier[0][1];			//			//trace("checking scene hornet",bugEntry.width,bugEntrypt[0][0]);//			hero_mc.X = sonicPts[0][0];//			hero_mc.Y = sonicPts[0][1];//			spawn1 = new MovieClip(Assets.getAtlas().getTextures("blink"),24)//			spawn2 = new MovieClip(Assets.getAtlas().getTextures("blink"),24)//			spawn1.X = 20//spawn1Pt[0][0]//			spawn1.y = 30//spawn1Pt[0][1]//			spawn2.x = 45//spawn2Pt[0][0]//			spawn2.y = 50//spawn2Pt[0][1]//			addChild(bigBaddie);//			bigBaddie.x = bigBadPts[0][0];//			bigBaddie.y = bigBadPts[0][1];			//hrnets.push(bigBaddie);			sonicPts = null;					//	Assets.isArmatureLoaded("Dotin")			//way too many things added right away			//test = addNewAnimatedScenary(13413.837937516404,1218.1001159051607,-20,Assets.getAtlas("testin").getTextures("targetingRecticle"))//			targetingRecticle = addNewAnimatedScenary(13413.837937516404,1218.1001159051607,-20,Assets.getAtlas("testing").getTextures("targetingRecticle"))//			//trace(hero_mc.X, hero_mc.Y);			//			for (var i:int = 0; i < 8; i++) 			//			{			//				////trace(i,textureImage+"0"+int(i+1).toString());			//							//				for (var j:int = 0; j < fMapRows; j++) 			//				{			//					//trace(i,textureImage+"0"+int((i+1)*(j+1)).toString());			//					if ((i+1)*(j+1)-1<9)			//						board.push(new Image(Assets.getTexture(textureImage+"0"+int((i+1)*(j+1)).toString())));				//					else			//						board.push(new Image(Assets.getTexture(textureImage+int((i+1)*(j+1)).toString())));			//									//								//					board[(i+1)*(j+1)-1].x = sqPixel*j;			//					board[(i+1)*(j+1)-1].y = sqPixel*i;			//								//					////trace(board[(i+1)*(j+1)-1].x," ",board[(i+1)*(j+1)-1].y);			//					//addChild(board[(i+1)*(j+1)-1]);			//				}						//				if (i<20) 			//				{			//					board[i].x = 256*i;			//					board[i].y = 0;			//								//				}else{			//								//					board[i].x = 256*(i-20);			//					board[i].y = 512;			//				}									//			}																		//Assets.DynamicTexture();			//			addChild(dij);			//			dij.x = 0;			//			dij.y= 0;					}		//		public function LoadArmature(arm:String, big:Vector3):Armature//		{//			if(arm == null){//				arm = "Dotin"//			}//			//			//armature = Assets.getArmature(arm)//			Assets.finishedArmature = true//			armatureClip = armature.display as Sprite;//			//armature.animation.gotoAndPlay("throw");//			armatureClip.x = big.X;//			armatureClip.y = big.Y;//			addChildAt(armatureClip,2);//			armatureClip.alpha = 1;//			//				_head = armature.getBone("head");////			handR = armature.getBone("handR");////			handR.node.x = hero_mc.body.position.x////			handR.node.y = hero_mc.body.position.y//			return armature//			//			//		}						//		private function pushImage(ij:Image, i:uint, fromArray:Array = null):void		//		{		//			ij.removeFromParent(true);		//			ij = new Image(Assets.tileSheetSprite);		//			addChild(ij);		//			if (fromArray == null) 		//			{		//			ij.x =  que[i][1];		//			ij.y=  que[i][2];		//			}else{		//				ij.x =  fromArray[i][1];		//				ij.y=  fromArray[i][2];		//			}		//				//		}				public function UpdateMap(name:String):void		{			// umm really needs to be fixed 			updateCamPos();									//			 how this is gonna work is you load it here, when its dynamic you'll check if it needs to load based on the cameras location and size and it will load out the ones  it needs with a velocity bias						if(Assets.finished)			{				Assets.started = false;				Assets.finished = false;								for (var j:int = 0; j < live.length; j++) 				{					if(!live[j])						break				}				////trace(textureImage+waitList[j][0]," == ",Assets.stepimage);										if(waitList[j][0]< 10)					textureImage = name+"0"				else					textureImage = name								if(textureImage+waitList[j][0] == Assets.stepimage){															bgImages[j].removeFromParent(true);					bgImages[j] = new Image(Assets.getTexture(textureImage+waitList[j][0]))					bgImages[j].x =waitList[j][1];					bgImages[j].y =waitList[j][2];					map.addChild(bgImages[j])					////trace("tjos thing is here ",textureImage," ghg", bgImages[j].x, " ", bgImages[j].y)					live[j] = true;									}else{				//	Assets.LoadTexture(waitList[j][0])				}				//when the asset both hasnt started and hasnt finished that means its ready to load the next one on que																				// also remove the first one from the que stack move it to active			}			// we do both !started and not !finished so we dont load the same tile on two different spots			if(!Assets.started && !Assets.finished && que.length > 0)			{				//render texture eventually				//map.unflatten()				knum = 0;				////trace("got called");				for (var k:int = 0; k < iterNum; k++){ 					// this had name to it i must of changed istexture loaded in a dumb way but i have no idea how i changed it					// so i just put two i think this shit is deprecated anyway so it shouldnt matter.. maybe					if(false)//Assets.isTextureLoaded(que[k][0],2))					{						if(que[k][0]< 10)							textureImage = name+"0"						else							textureImage = name												bgImages[k].removeFromParent(true);						bgImages[k] = new Image(Assets.getTexture(textureImage+que[k][0]))						////trace("loaded ques"," ",k," ",que[k][0]," ",que[k][1]," ",que[k][2])							bgImages[k].x = que[k][1];						bgImages[k].y = que[k][2];						map.addChild(bgImages[k])												live[k] = true;					}else{ 						////trace("not loaded ques"," ",k," ",que[k][0]," ",que[k][1]," ",que[k][2])							live[k] = false;						if (waitList[k] != que[k]) 						{							waitList[k] = que[k]						}																							}																			}								for (var g:int = 0; g < live.length; g++) 				{					if(!live[g])						break				}				////trace(g);				if (g < live.length) 				{					//Assets.LoadTexture(waitList[g][0])				}															}												if(hero_mc.key.X>= 0)				camAdjust = true			else				camAdjust = false						// some weird load error work around this map thing i wrote is really shitty but it works			if (!camAdjust) 				relMapCam.X = pos.X+pheight/2- map.x;			else				relMapCam.X = pos.X+pwidth/2 - map.x;							relMapCam.Y = pos.Y+pheight/4 - map.y;			// we'd be like if the things in the bounds do this						column = int((relMapCam.X)/sqPixel);			row = int((relMapCam.Y)/sqPixel);						//it would be the int(mapWidth/512) which in this case is 40 actwally just get this from the tmx			// we dont need this yet but when were using the map			var i:uint =row*79+column;						//if(gid[i] != 0)			//{									if(i < 632 && i > 1){				que[0][0] = i+1;				que[0][1] = column*sqPixel;				que[0][2] = row*sqPixel;				var y:uint = 0;				// the 2 in rws loop represents the number of rows total in the map incase of zooms and such in other words that 2 needs to be adjusted for scale for optimazation i may just never do it, hopefully wont actually				//i2 represents columns //whole loop this represents the ones < than your screen u can create another loop for greater				for (var rws:int = 0; rws < visRows; rws++) 				{															for (var clms:int = 0; clms < iterNum/visRows; clms++) 					{												if((row-rws)*fMapRows+(column-clms) <632 && (row-rws)*fMapRows+(column-clms) >= 0){														//					if(que.length < (clms+1)*(rws+1)-1)							//					que.push((row-rws)*fMapRows+(column-clms)+1)														que[y][0]=(row-rws)*fMapRows+(column-clms)+1;							que[y][1]=(column-clms)*sqPixel;							que[y][2]=(row-rws)*sqPixel;							////trace("orig ques"," ",y," ",que[(clms+1)*(rws+1)-1][0]," ",que[y][1]," ",que[y][2])							y++						}					}				}											}								}				private function updateCamPos():void		{			// TODO Auto Generated method stub					}						public function ManualUpdateParallaxSpeed(foreground:Number = -1, background:Number = .5, farBack:Number = .75, farthestBack:Number = 1):void		{			//okay what were gonna do is make sets uninteractable possibly animatible set pieces that creat the illusion of depth, sonic stays in the midground 			///and has other ways of dealing with faux 3d but the sets make the whole world feel 3d and we can do things, but its purely decorative			// so we'll have different set pieces specific for parallax and become active once they are in sonics distance which is a bit bigger than the screen			// alright so -			foregroundSpeed = foreground;			backgroundSpeed = background;			farBackSpeed = farBack;			farthestBackSpeed = farthestBack					}				//just put in 3 or 4 for which set you want it to rotate around		public function UpdateRotationSet(rotateAround:int):void		{						// real rotation round y would go like so			// p 350ish			//x = cos(angleY)*x - sin(angleY)*z;			//z = cos(angleY)*z + sin(angleY)*x;						switch(rotateAround)			{				case 3:				{					ManualUpdateParallaxSpeed(-1,1,1.5,2);					break;				}				case 4:				{					ManualUpdateParallaxSpeed(-1,.75,1,1.25);					break;				}									default:				{					throw new Error("can not rotate around set, out of range");					break;				}			}					}				// call this from main to get all the speeds		public function UpdateSetPiece(setPiece:Sprite):void		{			var x:Number = (pos.X+pwidth/2);			var y:Number = (pos.Y+pheight/2);			// think of the foreground background farback and farthest like an array their types are equal to those ints			//			if(setPiece.type == 0){			//			setPiece.x = vpX + (x-vpX)*foregroundSpeed;			//			setPiece.y = vpY + (y-vpY)*foregroundSpeed;			//			}else if(setPiece.type == 2){			//			setPiece.x = vpX + (x-vpX)*backgroundSpeed;				//			setPiece.y = vpY + (y-vpY)*backgroundSpeed;				//			}else if(setPiece.type == 3){			//				setPiece.x = vpX + (x-vpX)*farBackSpeed;					//				setPiece.y = vpY + (y-vpY)*farBackSpeed;			//			}else if(setPiece.type == 4){			//				setPiece.x = vpX + (x-vpX)*farthestBackSpeed;			//				setPiece.y = vpY + (y-vpY)*farthestBackSpeed;			//			}		}				public override function UpdatePlacement(Coordinates:Vector3, state:String = null):void		{			x = -Coordinates.X + 450;			y = -Coordinates.Y + 340; //480/2 +100;			//			scaleX = Coordinates.Z/someVal;			//			scaleY = Coordinates.Z/someVal;			motorAnim = state;						//Vibration()					}				public function Vibration():void		{			// adds a nice vibration			spd = 1			angle += 8			x +=Math.cos(angle)*(spd);			y +=Math.sin(angle)*(spd);		}				public function get vpX():Number		{			return _vpX;		}				public function set vpX(value:Number):void		{			_vpX = value;		}				public function get vpY():Number		{			return _vpY;		}				public function set vpY(value:Number):void		{			_vpY = value;		}				public function get fl():Number		{			return _fl;		}				public function set fl(value:Number):void		{			_fl = value;		}				public function get hero_mc():Hero		{			return _hero_mc;		}				public function set hero_mc(value:Hero):void		{			_hero_mc = value;		}				public function get baddies():Array		{			return _baddies;		}				public function set baddies(value:Array):void		{			_baddies = value;		}				public function get sonicMoved():Boolean		{			return _sonicMoved;		}				public function set sonicMoved(value:Boolean):void		{			_sonicMoved = value;		}						public function get fightScene_mc():FightScene		{			return _fightScene_mc;		}				public function set fightScene_mc(value:FightScene):void		{			_fightScene_mc = value;		}				public function get scnes():Vector.<SceneHandler>		{			return _scnes;		}				public function set scnes(value:Vector.<SceneHandler>):void		{			_scnes = value;		}				public function get bigBaddie():BaddieBoss		{			return _bigBaddie;		}				public function set bigBaddie(value:BaddieBoss):void		{			_bigBaddie = value;		}				public function get targetingRecticle():AnimatedScenary		{			return _targetingRecticle;		}				public function set targetingRecticle(value:AnimatedScenary):void		{			_targetingRecticle = value;		}				public function get spawn1():MovieClip		{			return _spawn1;		}				public function set spawn1(value:MovieClip):void		{			_spawn1 = value;		}				public function get spawn2():MovieClip		{			return _spawn2;		}				public function set spawn2(value:MovieClip):void		{			_spawn2 = value;		}				public function get hrnets2():Array		{			return _hrnets2;		}				public function set hrnets2(value:Array):void		{			_hrnets2 = value;		}				public function get hrnets3():Array		{			return _hrnets3;		}				public function set hrnets3(value:Array):void		{			_hrnets3 = value;		}				public function get hrnets4():Array		{			return _hrnets4;		}				public function set hrnets4(value:Array):void		{			_hrnets4 = value;		}				public function get hrnets5():Array		{			return _hrnets5;		}				public function set hrnets5(value:Array):void		{			_hrnets5 = value;		}				public function get hrnets6():Array		{			return _hrnets6;		}				public function set hrnets6(value:Array):void		{			_hrnets6 = value;		}				public function get hornetBossScene():HornetBossScene		{			return _hornetBossScene;		}				public function set hornetBossScene(value:HornetBossScene):void		{			_hornetBossScene = value;		}				public function get baddiSpots():Array		{			return _baddiSpots;		}				public function set baddiSpots(value:Array):void		{			_baddiSpots = value;		}				public function get baddiRects():Array		{			return _baddiRects;		}				public function set baddiRects(value:Array):void		{			_baddiRects = value;		}		//		public function get armature():Armature//		{//			return _armature;//		}//		//		public function set armature(value:Armature):void//		{//			_armature = value;//		}				public function get rings():Array		{			return _rings;		}				public function set rings(value:Array):void		{			_rings = value;		}				public function get armatureClip():Sprite		{			return _armatureClip;		}				public function set armatureClip(value:Sprite):void		{			_armatureClip = value;		}				public function get map():Map		{			return _map;		}				public function set map(value:Map):void		{			_map = value;		}				public function get mapTest():Sprite		{			return _mapTest;		}				public function set mapTest(value:Sprite):void		{			_mapTest = value;		}				public function get pwidth():Number		{			return _pwidth;		}				public function set pwidth(value:Number):void		{			_pwidth = value;		}				public function get pheight():Number		{			return _pheight;		}				public function set pheight(value:Number):void		{			_pheight = value;		}				public function get collisionVolumes():Array		{			return _collisionVolumes;		}				public function set collisionVolumes(value:Array):void		{			_collisionVolumes = value;		}				public function get collisionTarget():Target		{			return _collisionTarget;		}				public function set collisionTarget(value:Target):void		{			_collisionTarget = value;		}				public function get scenary():Array		{			return _scenary;		}				public function set scenary(value:Array):void		{			_scenary = value;		}		public function get test():AnimatedScenary
		{
			return _test;
		}		public function set test(value:AnimatedScenary):void
		{
			_test = value;
		}											}}


