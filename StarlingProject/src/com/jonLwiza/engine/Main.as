package com.jonLwiza.engine{	import com.jonLwiza.engine.GeneralElements.Director;	import com.jonLwiza.engine.GeneralElements.GroupDynamix;	import com.jonLwiza.engine.IO.KeyPress;	import com.jonLwiza.engine.Scenes.DynamicBlock;	import com.jonLwiza.engine.Scenes.FightScene;	import com.jonLwiza.engine.Scenes.HornetBossBattle;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainScene;	import com.jonLwiza.engine.Scenes.GeneralSceneAssets.MainSceneMotor;	import com.jonLwiza.engine.actors.BaddieBoss;	import com.jonLwiza.engine.actors.Hero;	import com.jonLwiza.engine.actors.Hornet;	import com.jonLwiza.engine.actors.MainStage;	import com.jonLwiza.engine.actors.Scenary;	import com.jonLwiza.engine.baseConstructs.Baddie;	import com.jonLwiza.engine.baseConstructs.GeneralMotor;	import com.jonLwiza.engine.baseConstructs.NPC;	import com.jonLwiza.engine.baseConstructs.SceneHandler;	import com.jonLwiza.engine.baseConstructs.Trigger;	import com.jonLwiza.engine.helperTypes.ActorPool;	import com.jonLwiza.engine.helperTypes.QuickRect;	import com.jonLwiza.engine.helperTypes.SpritePool;	import com.jonLwiza.engine.helperTypes.Vector3;		import flash.display.Scene;	import flash.events.ErrorEvent;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.net.FileReference;	import flash.utils.getTimer;		import starling.core.Starling;	import starling.display.BlendMode;	import starling.display.Canvas;	import starling.display.Shape;	import starling.display.Sprite;	import starling.events.EnterFrameEvent;	import starling.events.Event;	import starling.geom.Polygon;	import starling.text.TextField;	import starling.utils.Color;	import starling.utils.LineSet;
		public class Main extends Sprite	{				private var etAlia:Array = [[0,400], [900,450]];		private var rings:Array;		private var baddies:Array;		private var testgroup1:Array;		private var scnes:Vector.<SceneHandler> = new Vector.<SceneHandler>();;		private var msm:MainSceneMotor = new MainSceneMotor();		//		private var ms:MainScene = new MainScene();//		private var fs:FightScene = new FightScene();		//private var hrnet:Hornet = new Hornet();		private var key:KeyPress = new KeyPress();		private var hero:Hero;		private var npcs:Array;		// I think I may have broken this needs checking		public var gDym:GroupDynamix = new GroupDynamix();				// should be a randomly generated number in the confines of some space when sonic holds him where the hero/sonic rotates around		//private var focus		private var position:TextField = new TextField(200,80,"position");		private var releasedDuringJump:Boolean;		private var stage_mc:MainStage = new MainStage();		public static var liveCamera:MainStage;		public static var testing:uint = 2;		public static var liveDirector:Director		private var _iter:uint =0;		private var lastQuickRect:QuickRect;		private var hrntGrp:int;		private var updatetest:Boolean;		private var midGroundPos:Vector3 = new Vector3;		private var scenary:Array;		public static var tick:int = 0;		private var totalTime:Number = 0;		private var frameCount:int;		private var director:Director = new Director()		public static var autoCam:Boolean = true;		public static var overrideRecticle:Boolean = false;		/**THIS IS THE CHECK TO SEE IF WE ARE IN EDIT MODE OR RELEASE**/		public static var Release:Boolean;		private var _previousTime:Number = 0;		var _line:LineSet				public function Main()		{			super();		addEventListener(Event.ADDED_TO_STAGE, allLoaded);		}				protected function allLoaded(event:Event):void		{					removeEventListener(Event.ADDED_TO_STAGE, allLoaded);		Assets.InitFrames();		// were gonna do this rather stupid here		// but load all the assets for every scene upfornt for right now		///**************************************     ********  *****///		// itll look something like this		// we have to check if its an animation  then do this, otherwise we just put in and load the texture without the 0's		//		//for(var i=0;i< Assets.Frames[/*whatever the loop of the animation*/].totalFrames; i++)		// load it up t if(i < 10)		//Assets.LoadTexture(/*whatever the loop of the animation,i*/)		// if i > 10 		addChild(stage_mc);		addToStage();		addChild(key);		addChild(position)		position.color = 0xff0000		position.scaleX = 1		position.scaleY = 1		position.alpha = 1;		//hmm a little disgusted with myself using an enterframe... but whatevs		addEventListener(Event.ENTER_FRAME, gameLoop);		 		 					var v:Vector3D = new Vector3D()		v.x = 100		v.y = 100		v.z = 0		//_line.addSegment(new Point(v.x,v.y),MainSceneMotor.project2Point(new Vector3D()),Color.WHITE);					//			stage_mc.addChild(circ)//				//			circ.graphics.clear()//			circ.graphics.beginFill(0xff0000)//			circ.graphics.drawCircle(400, 0, 50)		//	circ.			// I opted to do it this way, because it just doesnt know what scene it is until its called, another way maybe to call initialize on the hornets which would add them in and set the scene//		gDym.graphics.beginFill(0xFF0088);//		gDym.graphics.drawRect(0, 0, 80, 80);//		gDym.graphics.endFill();		stage_mc.gDym.alpha = 0.2		stage_mc.addChild(stage_mc.gDym)			//position.x = 500		 stage_mc.x = 0;		 stage_mc.y = 0;		 hero = stage_mc.hero_mc;		 stage_mc.hero_mc.currScene =[MainScene(stage_mc.mainScene_mc)];		 stage_mc.hero_mc.currScene[0].init(stage_mc.hero_mc);		 //test array				 // basically were not changing anything, we just want the thing to initialize a new group at new places so yeah we'll do this on the fly, but initialize and loading		 // should be done relatively similar times, on optimization consider seperating the object from its position, more like using a target position itd like to be so we		 // can simply just track a bunch of points rather than all dem, also later make a group leader, even if the leader doesnt do anything we can still use it for relative positioning		 // honestly not immportant now but coul be more important outside of sonic		 //stage_mc.gDym.initialize(stage_mc.hero_mc, stage_mc.hrnets);//baddies);		 // since death takes the actor out of the scene dont put death in group dynamics we can loosely check for it, but thats more like a bandaid		 ActorPool.init(Hornet, 4);				// i should just call director.next scene i dont need that shit in there since director has all that info				 liveCamera = stage_mc;		 liveDirector = director;		 MainScene.director = director		 MainScene.hero = stage_mc.hero_mc		director.init();															}								private function gameLoop(event:EnterFrameEvent):void		{ 			//trace(hero.facingAngle, " and the other", hero.currAngle*180/Math.PI)			var currentTime:Number = getTimer();			Main.liveCamera.dt = (currentTime - _previousTime)/1000;			_previousTime = currentTime;			if(tick%6 == 0){						var bodyX:int = stage_mc.hero_mc.bdy.x			var bodyY:int = stage_mc.hero_mc.bdy.y			position.text = "sonic.body.x = "+bodyX.toString()+"\n"+"sonic.body.y = "+bodyY.toString()+"\n"+"sonicX = "+int(hero.X).toString()+"   sonicY = "+int(hero.Y).toString()+"    sonicZ = "+int(hero.Z).toString()//45			}						 if(hero.dead){				 //trace("DEAD")				 director.RestartScene()					 hero.dead = false			 }						hero.dead = false//			totalTime += event.passedTime;//			if (++frameCount % 60 == 0)//			{//				//				trace("fps: " + frameCount / totalTime);//				frameCount = totalTime = 0;//				//			}				//I dont know if this is necessary at all			if(!Main.Release){			EditKeyHandler.InGameCamUpdate()			}else{							}							MainStage.X = stage_mc.pos.X			MainStage.Y = stage_mc.pos.Y			MainStage.Z = stage_mc.pos.Z		//stage_mc.UpdateMap("interp_");//				stage_mc.UjupdateMap(stage_mc.mapTest,"interp_",midGroundPos);				stage_mc.map.Update("interp_",stage_mc);				UpdateDist();				UpdateUI();				// this be the brains and cutscenes.. praya.. thats like asian mispronounced playa youget it, its funny aint it.... god im going innnnsssaaaaanneee, one day im gonna read all these and understand the full depth of whats wrong with me, or not.				// this is ok for now but since this is cutscene appropriate we need to um do other things								// this is like a super slow iterrator I iterrate by the frame, but the logic follows that the slowest itll ever be is 1/8th of 60 fps, and most groups are too far for that to ever matter 				////trace(stage_mc.hero_mc.x);				////trace(hero.isGrounded)//				stage_mc.gDym.x = stage_mc.hero_mc.x//				stage_mc.gDym.y = stage_mc.hero_mc.y			//this feeds into either the thing that changes the scene and takes stage and does what it needs to with it, either with a simple implementation of the FSM to handle moving from scene to			// scene also when it gets a scene we use the main running around scene as the archtype for the otherscenes which it will automatically subclass through the autogenerated classes			// a motor and animation class which will have plug-ins for changing the speeds replacing animations and simple stuff			// if it needs alot of cusomization itll give me two blank classes with the naming convention i want for the motor and/or the animation class which i can then subclass off of as well later			if(stage_mc.hero_mc.currScene[0] == null || stage_mc.hero_mc.currScene[0] == undefined)			{				if(stage_mc.hero_mc.inFight){									//stage_mc.hero_mc.currScene =[FightScene(stage_mc.fightScene_mc)];				}else{				stage_mc.hero_mc.currScene[0] =MainScene(stage_mc.mainScene_mc);				}											}			Assets.runLoadQue();			// this is a mess made it hard to find i should of made the key presses just public static but i was oop crazy, but then again i need the decoupling of what the press is to what it does hmm			// on rewriting just do two the rawKeyboard structure and the transientKeyboard Structure			stage_mc.hero_mc.key = key.direction;			stage_mc.hero_mc.spacebar = KeyPress.spacebar;			//msm.UpdateMotor(stage_mc.hero_mc);			stage_mc.hero_mc.currScene[0].UpdateCamera(stage_mc, stage_mc.ctScene_mc);			//**** extremely stupid putting this here this has to be changed			// try and putting update camera here instead of where i had it						// umm its not follow because stuff			// Im not 100% why I would need this  i think I'll always 			// have this for editing sooooo... I dont think I need to			//create a button for this			if(!Main.Release){				if(LevelEditor.isFollowSonic && !LevelEditor.isFollowPath){					LevelEditor.awyCam.z = Main.liveCamera.hero_mc.Z - 900;					LevelEditor.awyCam.rotationX = -180					LevelEditor.awyCam.x = Main.liveCamera.hero_mc.X;					LevelEditor.awyCam.y = Main.liveCamera.hero_mc.Y;				}			}else{				if(StarlingProject.isFollowSonic && !StarlingProject.isFollowPath){										StarlingProject.awyCam.z = Main.liveCamera.hero_mc.Z + 900;					StarlingProject.awyCam.x = Main.liveCamera.hero_mc.X;					StarlingProject.awyCam.y = Main.liveCamera.hero_mc.Y;				}			}						switch(testing)
			{
				case 1:
				{
					stage_mc.speed.X = (stage_mc.pos.X - stage_mc.hero_mc.body.position.x)/6;					stage_mc.speed.Y  = (stage_mc.pos.Y - stage_mc.hero_mc.body.position.y)/6;
					break;
				}
				case 2:
				{					if(autoCam){																		
//					stage_mc.speed.X = (stage_mc.pos.X - stage_mc.hero_mc.X)/6;//					stage_mc.speed.Y  = (stage_mc.pos.Y - stage_mc.hero_mc.Y)/6//					stage_mc.pos.Z = stage_mc.hero_mc.Z 					}
					break;
				}
				
					
				default:
				{
					break;
				}
			}						stage_mc.hero_mc.currScene[0].Update(stage_mc.hero_mc)						//stage_mc.hero_mc.			if(!stage_mc.hero_mc.isFrozen){			stage_mc.hero_mc.Update()			stage_mc.hero_mc.animationSeq.tick();			// this should be better but later			}			//Jumping this codes gotta get cleaned up just for clarification and whatnot						// think of these bools as states so when we clean this stupid thing up			////trace(stage_mc.hero_mc.isGrounded);			// UGGGHHH  THIS IS A HORRID MESSS!!!!!!!!!!!!!!!!!!!!!!!!//BLARGH I DONT WANNA DEAL SORTING THROUGHT THIS UGLY THING RIGHT NOW		//			if(!key.spacebar)//			stage_mc.hero_mc.triggerJumping = false;						//this should obviously be cleaned up and put in the behavior tree, but this is not the time to do that right now so we'll leave it like this						////trace(stage_mc.hero_mc.attacking);//*****Important debug code***		////trace(stage_mc.hero_mc.currMBehaviour);			//terrible place to put this please please move this or something, actualy the whole jumping thing			if(stage_mc.hero_mc.attacking){				//throw new Error("what up");				if(stage_mc.hero_mc.closestConcern != null)				if(stage_mc.hero_mc.closestConcern.distToSonic < 50)				{					//					stage_mc.hero_mc.closestConcern.Destroy()//						stage_mc.hero_mc.attacking = false;//						releasedDuringJump = true;//						stage_mc.hero_mc.doublejumped = false;				}			}						////trace(stage_mc.hero_mc.isGrounded)			if(stage_mc.hero_mc.isGrounded){			//stage_mc.hero_mc.isJumping = false;			//stage_mc.hero_mc.attacking = false;									//			 if(stage_mc.targetingRecticle.alpha == 1){//				 stage_mc.targetingRecticle.alpha = 0;//			 }			 			}else{//				if(stage_mc.targetingRecticle.alpha == 1)//					stage_mc.targetingRecticle.alpha = 1;//				stage_mc.targetingRecticle.x = stage_mc.hero_mc.closestConcern.x;//				stage_mc.targetingRecticle.y = stage_mc.hero_mc.closestConcern.y;				//stage_mc.hero_mc.closestConcern.alpha = 0;							}						// so now it says if were in the isJumping state and we arent triggering jump anymore this means we have jumped, and we have double jump enable 			// we could right it in the header of the if but since if im not lazy ill move this to the behavior thingy were not gonna put this code in the header			if(!overrideRecticle){						if(stage_mc.hero_mc.isJumping)			{				if(stage_mc.hero_mc.closestConcern !=null)				if(stage_mc.hero_mc.closestConcern.distToSonic < 400){					////trace(stage_mc.hero_mc.localBaddies)//				stage_mc.targetingRecticle.alpha = 1//					//				stage_mc.targetingRecticle.x = stage_mc.hero_mc.closestConcern.x//				stage_mc.targetingRecticle.y = stage_mc.hero_mc.closestConcern.y				}else if(stage_mc.hero_mc.closestConcern.dead)				{				//	stage_mc.targetingRecticle.alpha = 0;				}							if(!KeyPress.spacebar )				{					////trace("jumping is", key.spacebar);					stage_mc.hero_mc.releasedDuringJump = true;									}else{					// this shouldnt be here but im am upset this is taking so long so i have reached a limit with patience:: note learn how to spell patienrdfjklaghkldajghfj fuck patiefuck					hero.body.velocity.y-=10;				}			  //if(key.spacebar)			// this means we've jumped				////trace(!stage_mc.hero_mc.triggerJumping, " && ",releasedDuringJump," && ",key.spacebar, " && ",!stage_mc.hero_mc.doublejumped)				////trace(stage_mc.hero_mc.localBaddies);				for each (var j:Hornet in stage_mc.hero_mc.localBaddies) 
				{
					////trace(j.x,j.y, " ",j.dead);
					
				}
								////trace("should be jumping ");				if(stage_mc.hero_mc.closestConcern != null)				if(!stage_mc.hero_mc.triggerJumping && stage_mc.hero_mc.releasedDuringJump && KeyPress.spacebar && !stage_mc.hero_mc.doublejumped && !stage_mc.hero_mc.hanging && !stage_mc.hero_mc.closestConcern.dead)				{					stage_mc.hero_mc.releasedDuringJump = false;					stage_mc.hero_mc.doublejumped = true;					// for general purposes we'd call double jump then have this overide to do homing but youknow its just names so whatevs really, if i made an engine i could say that it overrides double jump instead of main scenes homing										////trace("homing attack")					stage_mc.hero_mc.currScene[0].SonicDoubleJump(stage_mc.hero_mc);				}													}else{//				trace(stage_mc.targetingRecticle.movie.numFrames)//				stage_mc.targetingRecticle.alpha = 1////				stage_mc.targetingRecticle.X = -2265////				stage_mc.targetingRecticle.Y = 1416////				stage_mc.targetingRecticle.Z = 625//				stage_mc.targetingRecticle.movie.loop = true			}		}			//throw new Error("you did something wrong");						// i dunno where any of the shit is for this code but uh, whateves			////trace(stage_mc.hero_mc.cutsIn)			//stage_mc.x -=2.5;			////trace(key.direction.X, key.direction.Y);			// i can get away with not putting this in a for it should be fine				// this IS THE PLACE WHERE I PUUUTTT THE EEEE ECCOOOOODDED DD ODODODODODODODODOEKEJKRLSAKJR;DS A FOR THE AI AND SEE IF BEHAVIOR TREE WORKSSS!!! WHICH IT WONT BUT WILL HOPEFULLY EVENTUALLY																
			
											//stage_mc.hornet.UpdateBtrees();			//stage_mc.hornet.hornetBtree.tick();			//stage_mc.hornet.hornetBtree.tick();		}				private function UpdateUI():void		{//			ui_mc.rings_txt.text = String(stage_mc.hero_mc.rings);//			ui_mc.lives_txt.text = String(3);		}		private function dsf():void		{			var allchars:Array = stage_mc.npcs			allchars.push(stage_mc.hero_mc)			allchars.sortOn("Z", Array.DESCENDING | Array.NUMERIC);			for(var i:uint = 0; i < allchars.length; i++)			{								stage_mc.setChildIndex(GeneralMotor(allchars[i]), i);			}		}		private function UpdateDist():void		{						//I dont know what i wrote before but were just gonna ignore that heap, just focus on one thing, do good, literally good			// here's what you need to do create the thing to update the distance of every object in the list of array its like rings badguys whatever, right now they just have an on enterframe, but we'll take that away												stage_mc.gDym.Update(stage_mc.hero_mc)						// for later i recommend splitting this into two doing one for the rings or other objects and one for the baddies, so i can get closest baddi and closest ring			if (stage_mc.hero_mc.closestConcern == null ||stage_mc.hero_mc.closestConcern.x == 0 ||stage_mc.hero_mc.closestConcern.dead ) 
			{				for (var k:int = 0; k < stage_mc.hero_mc.localBaddies.length; k++) 
				{					if(!stage_mc.hero_mc.localBaddies[k].dead){
					stage_mc.hero_mc.closestConcern = stage_mc.hero_mc.localBaddies[k];					break					}				}
				
				
			}			for (var i:int = 0; i < stage_mc.npcs.length; i++) 			{				if(!stage_mc.npcs[i].dead && stage_mc.hero_mc.closestConcern != null){				stage_mc.npcs[i].Update(stage_mc.hero_mc)																										if(stage_mc.hero_mc.closestConcern.distToSonic > stage_mc.npcs[i].distToSonic && !stage_mc.npcs[i].isHeld){																		stage_mc.hero_mc.closestConcern = stage_mc.npcs[i];																	} else if(stage_mc.npcs[i].isHeld && stage_mc.npcs[i] == stage_mc.hero_mc.closestConcern){													stage_mc.hero_mc.closestConcern = stage_mc.npcs[i-1];																	}											////trace(npcs[i].distToSonic)				// very simplistically, but i guess we should track what scene the things are in the controller, so the hornets dont arbritrarily keep searching for every scene								if(stage_mc.npcs [i].currScene[0] == null || stage_mc.npcs[i].currScene[0] == undefined)				{					// I might just put these in their respective updates				if(stage_mc.npcs[i].inFight)					stage_mc.npcs[i].currScene =[FightScene(stage_mc.fightScene_mc)];				else{					stage_mc.npcs[i].currScene =[MainScene(stage_mc.mainScene_mc)];				}				}//				// you would put a for each that goes through all the scenes here, but later make it a smarter for each, that checks based on its location, like if its near sonic but does an initial update, this may limit things, so i need to be clever about this//															}							}						for (var i2:int = 0; i2 < stage_mc.rings.length; i2++) 
			{
				stage_mc.rings[i2].Update(stage_mc.hero_mc);
			}
						for (var i3:int = 0; i3 < stage_mc.scenary.length; i3++) 
			{
				stage_mc.scenary[i3].Update();
			}
						for (var j:int = 0; j < stage_mc.baddies.length; j++) 
			{				if(!stage_mc.baddies[j].dead)
				stage_mc.baddies[j].Update(stage_mc.hero_mc);			}
									// We need to use this but it has to work first//			for ( j = 0; j < stage_mc.hero_mc.localBaddies.length; j++) //			{//				//				if(stage_mc.hero_mc.localBaddies[j].dead){//					stage_mc.hero_mc.localBaddies.splice(j,1)//					stage_mc.removeChild(stage_mc.hero_mc.localBaddies[j])//					if(stage_mc.hero_mc.localBaddies[j]!= null)//					ActorPool.returnSprite(stage_mc.hero_mc.localBaddies[j])//						//				}//			}						// this should be optimized			for each (var s:SceneHandler in stage_mc.scnes) 			{								s.OnEnterFrame(stage_mc.hero_mc)					////trace(s.width)			}			//			//			//this is how we get the animation behaviour working later we'll apply these to baddies and sonic directly			//stage_mc.bigBaddie.animationSeq.tick();						if(Assets.finishedArmature)			{				//stage_mc.LoadArmature();								//				_armL = armature.getBone("armUpperL");				Assets.finishedArmature = false;				updatetest = true;			}			if (updatetest) 			{				// im gonna need to chanfe this to a for loop but whatevs				//stage_mc.armature.advanceTime(1/30)				//				if(armature.animation.isComplete){				//					armature.animation.gotoAndPlay("throw");				//									//				}			}								}				private function addToStage():void		{			// these should probably have initializations for all these characters to stop the NaN problem			// were gonna move this to camera just because			var s:MainStage = stage_mc			rings = [s.collisionTarget].concat(s.rings)//s.rings//[s.r1,s.r2,s.r3,s.r4,s.r5,s.r6,s.r7,s.r8,s.r9,s.r10,s.r11,s.r12,s.r13,s.r14,s.r15,s.r16,s.r17,s.r18,s.r19,s.r20,s.r21,s.r22,s.r23,s.r24,s.r25,s.r26,s.r27,s.r28,s.r29,s.r30,s.r31,s.r32,s.r33,s.r34,s.r35,s.r36,s.r37,s.r38, s.r39,s.r40];			baddies = s.baddies;//,s.hbHornet, stage_mc.h1,s.h2,s.h3,s.h4,s.h5,s.h6,s.h7,s.h8,s.h9,s.h10,s.h11,s.h12,s.h13,s.h14,s.h15,s.h16,s.h17,s.h18,s.h19,s.h20,s.h21,s.h22,s.h23,s.h24,s.h25,s.h26,s.h27,s.h28,s.h29,s.h30,s.h31,s.h32,s.h33,s.h34,s.h35,s.h36,s.h37,s.h38, s.h39,s.h40, s.bBoss]//			testgroup1 = [s.bBoss];			scenary  = s.scenary			s.npcs = baddies;//			//trace						////trace(npcs);			scnes = s.scnes;//.push([SceneHandler(s.hornetNest), SceneHandler(s.bugEntry),SceneHandler(s.hornetBossBattle)]);			s =null;		}		public function get iter():uint
		{
			return _iter;
		}		public function set iter(value:uint):void
		{
			_iter = value;
		}	}}